<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>4.2-BeautifulSoup的使用</title>
      <link href="/post/27af.html"/>
      <url>/post/27af.html</url>
      
        <content type="html"><![CDATA[<h2 id="4-2-使用-Beautiful-Soup"><a href="#4-2-使用-Beautiful-Soup" class="headerlink" title="4.2 使用 Beautiful Soup"></a>4.2 使用 Beautiful Soup</h2><p>前面介绍了正则表达式的相关用法，但是一旦正则表达式写的有问题，得到的可能就不是我们想要的结果了。而且对于一个网页来说，都有一定的特殊结构和层级关系，而且很多节点都有 id 或 class 来作区分，所以借助它们的结构和属性来提取不也可以吗？</p><p>这一节中，我们就来介绍一个强大的解析工具 Beautiful Soup，它借助网页的结构和属性等特性来解析网页。有了它，我们不用再去写一些复杂的正则表达式，只需要简单的几条语句，就可以完成网页中某个元素的提取。</p><p>废话不多说，接下来就来感受一下 Beautiful Soup 的强大之处吧。</p><h3 id="1-Beautiful-Soup-简介"><a href="#1-Beautiful-Soup-简介" class="headerlink" title="1. Beautiful Soup 简介"></a>1. Beautiful Soup 简介</h3><p>简单来说，BeautifulSoup 就是 Python 的一个 HTML 或 XML 的解析库，我们可以用它来方便地从网页中提取数据，官方的解释如下：</p><blockquote><p>BeautifulSoup 提供一些简单的、Python 式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。<br>BeautifulSoup 自动将输入文档转换为 Unicode 编码，输出文档转换为 utf-8 编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时你仅仅需要说明一下原始编码方式就可以了。<br>BeautifulSoup 已成为和 lxml、html5lib 一样出色的 Python 解释器，为用户灵活地提供不同的解析策略或强劲的速度。</p></blockquote><p>所以说，利用它可以省去很多烦琐的提取工作，提高了解析效率。</p><h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3><p>在开始之前，请确保已经正确安装好了 Beautiful Soup 和 lxml，如果没有安装，可以参考第 1 章的内容。</p><h3 id="3-解析器"><a href="#3-解析器" class="headerlink" title="3. 解析器"></a>3. 解析器</h3><p>Beautiful Soup 在解析时实际上依赖解析器，它除了支持 Python 标准库中的 HTML 解析器外，还支持一些第三方解析器（比如 lxml）。表 4-3 列出了 Beautiful Soup 支持的解析器。</p><p>表 4-3　Beautiful Soup 支持的解析器</p><table><thead><tr><th>解析器</th><th>使用方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Python 标准库</td><td>BeautifulSoup(markup, “html.parser”)</td><td>Python 的内置标准库、执行速度适中 、文档容错能力强</td><td>Python 2.7.3 or 3.2.2) 前的版本中文容错能力差</td></tr><tr><td>LXML HTML 解析器</td><td>BeautifulSoup(markup, “lxml”)</td><td>速度快、文档容错能力强</td><td>需要安装 C 语言库</td></tr><tr><td>LXML XML 解析器</td><td>BeautifulSoup(markup, “xml”)</td><td>速度快、唯一支持 XML 的解析器</td><td>需要安装 C 语言库</td></tr><tr><td>html5lib</td><td>BeautifulSoup(markup, “html5lib”)</td><td>最好的容错性、以浏览器的方式解析文档、生成 HTML5 格式的文档</td><td>速度慢、不依赖外部扩展</td></tr></tbody></table><p>通过以上对比可以看出，lxml 解析器有解析 HTML 和 XML 的功能，而且速度快，容错能力强，所以推荐使用它。</p><p>如果使用 lxml，那么在初始化 Beautiful Soup 时，可以把第二个参数改为 lxml 即可：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span><span class="token string">'&lt;p>Hello&lt;/p>'</span><span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>p<span class="token punctuation">.</span>string<span class="token punctuation">)</span></code></pre><p>在后面，Beautiful Soup 的用法实例也统一用这个解析器来演示。</p><h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4. 基本使用"></a>4. 基本使用</h3><p>下面首先用实例来看看 Beautiful Soup 的基本用法：</p><pre class=" language-python"><code class="language-python">html <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;html>&lt;head>&lt;title>The Dormouse's story&lt;/title>&lt;/head>&lt;body>&lt;p class="title" name="dromouse">&lt;b>The Dormouse's story&lt;/b>&lt;/p>&lt;p class="story">Once upon a time there were three little sisters; and their names were&lt;a href="http://example.com/elsie" class="sister" id="link1">&lt;!-- Elsie -->&lt;/a>,&lt;a href="http://example.com/lacie" class="sister" id="link2">Lacie&lt;/a> and&lt;a href="http://example.com/tillie" class="sister" id="link3">Tillie&lt;/a>;and they lived at the bottom of a well.&lt;/p>&lt;p class="story">...&lt;/p>"""</span><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>prettify<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>title<span class="token punctuation">.</span>string<span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>   The Dormouse's story  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dromouse<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">></span></span>    The Dormouse's story   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>b</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>story<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   Once upon a time there were three little sisters; and their names were   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sister<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://example.com/elsie<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>link1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- Elsie --></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>   ,   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sister<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://example.com/lacie<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>link2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    Lacie   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>   and   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sister<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://example.com/tillie<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>link3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    Tillie   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>   ;and they lived at the bottom of a well.  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>story<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   ...  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>The Dormouse's story</code></pre><p>这里首先声明变量 html，它是一个 HTML 字符串。但是需要注意的是，它并不是一个完整的 HTML 字符串，因为 body 和 html 节点都没有闭合。接着，我们将它当作第一个参数传给 BeautifulSoup 对象，该对象的第二个参数为解析器的类型（这里使用 lxml），此时就完成了 BeaufulSoup 对象的初始化。然后，将这个对象赋值给 soup 变量。</p><p>接下来，就可以调用 soup 的各个方法和属性解析这串 HTML 代码了。</p><p>首先，调用 prettify() 方法。这个方法可以把要解析的字符串以标准的缩进格式输出。这里需要注意的是，输出结果里面包含 body 和 html 节点，也就是说对于不标准的 HTML 字符串 BeautifulSoup，可以自动更正格式。这一步不是由 prettify() 方法做的，而是在初始化 BeautifulSoup 时就完成了。</p><p>然后调用 soup.title.string，这实际上是输出 HTML 中 title 节点的文本内容。所以，soup.title 可以选出 HTML 中的 title 节点，再调用 string 属性就可以得到里面的文本了，所以我们可以通过简单调用几个属性完成文本提取，这是不是非常方便？</p><h3 id="5-节点选择器"><a href="#5-节点选择器" class="headerlink" title="5. 节点选择器"></a>5. 节点选择器</h3><p>直接调用节点的名称就可以选择节点元素，再调用 string 属性就可以得到节点内的文本了，这种选择方式速度非常快。如果单个节点结构层次非常清晰，可以选用这种方式来解析。</p><h4 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h4><p>下面再用一个例子详细说明选择元素的方法：</p><pre class=" language-python"><code class="language-python">html <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;html>&lt;head>&lt;title>The Dormouse's story&lt;/title>&lt;/head>&lt;body>&lt;p class="title" name="dromouse">&lt;b>The Dormouse's story&lt;/b>&lt;/p>&lt;p class="story">Once upon a time there were three little sisters; and their names were&lt;a href="http://example.com/elsie" class="sister" id="link1">&lt;!-- Elsie -->&lt;/a>,&lt;a href="http://example.com/lacie" class="sister" id="link2">Lacie&lt;/a> and&lt;a href="http://example.com/tillie" class="sister" id="link3">Tillie&lt;/a>;and they lived at the bottom of a well.&lt;/p>&lt;p class="story">...&lt;/p>"""</span><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>title<span class="token punctuation">.</span>string<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>head<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>p<span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>The Dormouse's story<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">'bs4.element.Tag'</span><span class="token punctuation">></span></span>The Dormouse's story<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>The Dormouse's story<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dromouse<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">></span></span>The Dormouse's story<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>b</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><p>这里依然选用刚才的 HTML 代码，首先打印输出 title 节点的选择结果，输出结果正是 title 节点加里面的文字内容。接下来，输出它的类型，是 bs4.element.Tag 类型，这是 Beautiful Soup 中一个重要的数据结构。经过选择器选择后，选择结果都是这种 Tag 类型。Tag 具有一些属性，比如 string 属性，调用该属性，可以得到节点的文本内容，所以接下来的输出结果正是节点的文本内容。</p><p>接下来，我们又尝试选择了 head 节点，结果也是节点加其内部的所有内容。最后，选择了 p 节点。不过这次情况比较特殊，我们发现结果是第一个 p 节点的内容，后面的几个 p 节点并没有选到。也就是说，当有多个节点时，这种选择方式只会选择到第一个匹配的节点，其他的后面节点都会忽略。</p><h4 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h4><p>上面演示了调用 string 属性来获取文本的值，那么如何获取节点属性的值呢？如何获取节点名呢？下面我们来统一梳理一下信息的提取方式。</p><h5 id="获取名称"><a href="#获取名称" class="headerlink" title="获取名称"></a>获取名称</h5><p>可以利用 name 属性获取节点的名称。这里还是以上面的文本为例，选取 title 节点，然后调用 name 属性就可以得到节点名称：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>title<span class="token punctuation">.</span>name<span class="token punctuation">)</span></code></pre><p>运行结果:</p><pre><code>title</code></pre><h5 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h5><p>每个节点可能有多个属性，比如 id 和 class 等，选择这个节点元素后，可以调用 attrs 获取所有属性：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>p<span class="token punctuation">.</span>attrs<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>p<span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class=" language-python"><code class="language-python"><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;'class': ['title'], 'name': 'dromouse'&amp;#125;</span>dromouse</code></pre><p>可以看到，attrs 的返回结果是字典形式，它把选择的节点的所有属性和属性值组合成一个字典。接下来，如果要获取 name 属性，就相当于从字典中获取某个键值，只需要用中括号加属性名就可以了。比如，要获取 name 属性，就可以通过 attrs[‘name’] 来得到。</p><p>其实这样有点烦琐，还有一种更简单的获取方式：可以不用写 attrs，直接在节点元素后面加中括号，传入属性名就可以获取属性值了。样例如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>p<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>p<span class="token punctuation">[</span><span class="token string">'class'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre><code>dromouse[&#39;title&#39;]</code></pre><p>这里需要注意的是，有的返回结果是字符串，有的返回结果是字符串组成的列表。比如，name 属性的值是唯一的，返回的结果就是单个字符串。而对于 class，一个节点元素可能有多个 class，所以返回的是列表。在实际处理过程中，我们要注意判断类型。</p><h5 id="获取内容"><a href="#获取内容" class="headerlink" title="获取内容"></a>获取内容</h5><p>可以利用 string 属性获取节点元素包含的文本内容，比如要获取第一个 p 节点的文本：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>p<span class="token punctuation">.</span>string<span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre><code>The Dormouse&#39;s story</code></pre><p>再次注意一下，这里选择到的 p 节点是第一个 p 节点，获取的文本也是第一个 p 节点里面的文本。</p><h4 id="嵌套选择"><a href="#嵌套选择" class="headerlink" title="嵌套选择"></a>嵌套选择</h4><p>在上面的例子中，我们知道每一个返回结果都是 bs4.element.Tag 类型，它同样可以继续调用节点进行下一步的选择。比如，我们获取了 head 节点元素，我们可以继续调用 head 来选取其内部的 head 节点元素：</p><pre class=" language-python"><code class="language-python">html <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;html>&lt;head>&lt;title>The Dormouse's story&lt;/title>&lt;/head>&lt;body>"""</span><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>head<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>head<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>head<span class="token punctuation">.</span>title<span class="token punctuation">.</span>string<span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre><code>&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;class &#39;bs4.element.Tag&#39;&gt;The Dormouse&#39;s story</code></pre><p>第一行结果是调用 head 之后再次调用 title 而选择的 title 节点元素。然后打印输出了它的类型，可以看到，它仍然是 bs4.element.Tag 类型。也就是说，我们在 Tag 类型的基础上再次选择得到的依然还是 Tag 类型，每次返回的结果都相同，所以这样就可以做嵌套选择了。</p><p>最后，输出它的 string 属性，也就是节点里的文本内容。</p><h4 id="关联选择"><a href="#关联选择" class="headerlink" title="关联选择"></a>关联选择</h4><p>在做选择的时候，有时候不能做到一步就选到想要的节点元素，需要先选中某一个节点元素，然后以它为基准再选择它的子节点、父节点、兄弟节点等，这里就来介绍如何选择这些节点元素。</p><h5 id="子节点和子孙节点"><a href="#子节点和子孙节点" class="headerlink" title="子节点和子孙节点"></a>子节点和子孙节点</h5><p>选取节点元素之后，如果想要获取它的直接子节点，可以调用 contents 属性，示例如下：</p><pre class=" language-python"><code class="language-python">html <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;html>    &lt;head>        &lt;title>The Dormouse's story&lt;/title>    &lt;/head>    &lt;body>        &lt;p class="story">            Once upon a time there were three little sisters; and their names were            &lt;a href="http://example.com/elsie" class="sister" id="link1">                &lt;span>Elsie&lt;/span>            &lt;/a>            &lt;a href="http://example.com/lacie" class="sister" id="link2">Lacie&lt;/a>             and            &lt;a href="http://example.com/tillie" class="sister" id="link3">Tillie&lt;/a>            and they lived at the bottom of a well.        &lt;/p>        &lt;p class="story">...&lt;/p>"""</span><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>p<span class="token punctuation">.</span>contents<span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre class=" language-python"><code class="language-python"><span class="token punctuation">[</span><span class="token string">'\n            Once upon a time there were three little sisters; and their names were\n            '</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sister"</span> href<span class="token operator">=</span><span class="token string">"http://example.com/elsie"</span> id<span class="token operator">=</span><span class="token string">"link1"</span><span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span>Elsie<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sister"</span> href<span class="token operator">=</span><span class="token string">"http://example.com/lacie"</span> id<span class="token operator">=</span><span class="token string">"link2"</span><span class="token operator">></span>Lacie<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token punctuation">,</span> <span class="token string">' \n            and\n            '</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sister"</span> href<span class="token operator">=</span><span class="token string">"http://example.com/tillie"</span> id<span class="token operator">=</span><span class="token string">"link3"</span><span class="token operator">></span>Tillie<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token punctuation">,</span> <span class="token string">'\n            and they lived at the bottom of a well.\n        '</span><span class="token punctuation">]</span></code></pre><p>可以看到，返回结果是列表形式。p 节点里既包含文本，又包含节点，最后会将它们以列表形式统一返回。</p><p>需要注意的是，列表中的每个元素都是 p 节点的直接子节点。比如第一个 a 节点里面包含一层 span 节点，这相当于孙子节点了，但是返回结果并没有单独把 span 节点选出来。所以说，contents 属性得到的结果是直接子节点的列表。</p><p>同样，我们可以调用 children 属性得到相应的结果：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>p<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> child <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>p<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> child<span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre><code>&lt;list_iterator object at 0x1064f7dd8&gt;0             Once upon a time there were three little sisters; and their names were1 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;2 3 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;4              and5 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;6             and they lived at the bottom of a well.</code></pre><p>还是同样的 HTML 文本，这里调用了 children 属性来选择，返回结果是生成器类型。接下来，我们用 for 循环输出相应的内容。</p><p>如果要得到所有的子孙节点的话，可以调用 descendants 属性：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>p<span class="token punctuation">.</span>descendants<span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> child <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>p<span class="token punctuation">.</span>descendants<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> child<span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre><code>&lt;generator object descendants at 0x10650e678&gt;0             Once upon a time there were three little sisters; and their names were1 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;2 3 &lt;span&gt;Elsie&lt;/span&gt;4 Elsie5 6 7 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;8 Lacie9              and10 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;11 Tillie12             and they lived at the bottom of a well.</code></pre><p>此时返回结果还是生成器。遍历输出一下可以看到，这次的输出结果就包含了 span 节点。descendants 会递归查询所有子节点，得到所有的子孙节点。</p><h5 id="父节点和祖先节点"><a href="#父节点和祖先节点" class="headerlink" title="父节点和祖先节点"></a>父节点和祖先节点</h5><p>如果要获取某个节点元素的父节点，可以调用 parent 属性：</p><pre class=" language-python"><code class="language-python">html <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;html>    &lt;head>        &lt;title>The Dormouse's story&lt;/title>    &lt;/head>    &lt;body>        &lt;p class="story">            Once upon a time there were three little sisters; and their names were            &lt;a href="http://example.com/elsie" class="sister" id="link1">                &lt;span>Elsie&lt;/span>            &lt;/a>        &lt;/p>        &lt;p class="story">...&lt;/p>"""</span><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>a<span class="token punctuation">.</span>parent<span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>story<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            Once upon a time there were three little sisters; and their names were            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sister<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://example.com/elsie<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>link1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>Elsie<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><p>这里我们选择的是第一个 a 节点的父节点元素。很明显，它的父节点是 p 节点，输出结果便是 p 节点及其内部的内容。</p><p>需要注意的是，这里输出的仅仅是 a 节点的直接父节点，而没有再向外寻找父节点的祖先节点。如果想获取所有的祖先节点，可以调用 parents 属性：</p><pre class=" language-python"><code class="language-python">html <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;html>    &lt;body>        &lt;p class="story">            &lt;a href="http://example.com/elsie" class="sister" id="link1">                &lt;span>Elsie&lt;/span>            &lt;/a>        &lt;/p>"""</span><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>a<span class="token punctuation">.</span>parents<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>enumerate<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>a<span class="token punctuation">.</span>parents<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre class=" language-python"><code class="language-python"><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'generator'</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"story"</span><span class="token operator">></span><span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sister"</span> href<span class="token operator">=</span><span class="token string">"http://example.com/elsie"</span> id<span class="token operator">=</span><span class="token string">"link1"</span><span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span>Elsie<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"story"</span><span class="token operator">></span><span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sister"</span> href<span class="token operator">=</span><span class="token string">"http://example.com/elsie"</span> id<span class="token operator">=</span><span class="token string">"link1"</span><span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span>Elsie<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"story"</span><span class="token operator">></span><span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sister"</span> href<span class="token operator">=</span><span class="token string">"http://example.com/elsie"</span> id<span class="token operator">=</span><span class="token string">"link1"</span><span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span>Elsie<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"story"</span><span class="token operator">></span><span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sister"</span> href<span class="token operator">=</span><span class="token string">"http://example.com/elsie"</span> id<span class="token operator">=</span><span class="token string">"link1"</span><span class="token operator">></span><span class="token operator">&lt;</span>span<span class="token operator">></span>Elsie<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><p>可以发现，返回结果是生成器类型。这里用列表输出了它的索引和内容，而列表中的元素就是 a 节点的祖先节点。</p><h5 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h5><p>上面说明了子节点和父节点的获取方式，如果要获取同级的节点（也就是兄弟节点），应该怎么办呢？示例如下：</p><pre class=" language-python"><code class="language-python">html <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;html>    &lt;body>        &lt;p class="story">            Once upon a time there were three little sisters; and their names were            &lt;a href="http://example.com/elsie" class="sister" id="link1">                &lt;span>Elsie&lt;/span>            &lt;/a>            Hello            &lt;a href="http://example.com/lacie" class="sister" id="link2">Lacie&lt;/a>             and            &lt;a href="http://example.com/tillie" class="sister" id="link3">Tillie&lt;/a>            and they lived at the bottom of a well.        &lt;/p>"""</span><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Next Sibling'</span><span class="token punctuation">,</span> soup<span class="token punctuation">.</span>a<span class="token punctuation">.</span>next_sibling<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Prev Sibling'</span><span class="token punctuation">,</span> soup<span class="token punctuation">.</span>a<span class="token punctuation">.</span>previous_sibling<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Next Siblings'</span><span class="token punctuation">,</span> list<span class="token punctuation">(</span>enumerate<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>a<span class="token punctuation">.</span>next_siblings<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Prev Siblings'</span><span class="token punctuation">,</span> list<span class="token punctuation">(</span>enumerate<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>a<span class="token punctuation">.</span>previous_siblings<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre class=" language-python"><code class="language-python">Next Sibling             HelloPrev Sibling             Once upon a time there were three little sisters<span class="token punctuation">;</span> <span class="token operator">and</span> their names wereNext Siblings <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'\n            Hello\n            '</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sister"</span> href<span class="token operator">=</span><span class="token string">"http://example.com/lacie"</span> id<span class="token operator">=</span><span class="token string">"link2"</span><span class="token operator">></span>Lacie<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">' \n            and\n            '</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sister"</span> href<span class="token operator">=</span><span class="token string">"http://example.com/tillie"</span> id<span class="token operator">=</span><span class="token string">"link3"</span><span class="token operator">></span>Tillie<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'\n            and they lived at the bottom of a well.\n        '</span><span class="token punctuation">)</span><span class="token punctuation">]</span>Prev Siblings <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'\n            Once upon a time there were three little sisters; and their names were\n            '</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><p>可以看到，这里调用了 4 个属性，其中 next_sibling 和 previous_sibling 分别获取节点的下一个和上一个兄弟元素，next_siblings 和 previous_siblings 则分别返回后面和前面的兄弟节点。</p><h5 id="提取信息-1"><a href="#提取信息-1" class="headerlink" title="提取信息"></a>提取信息</h5><p>前面讲解了关联元素节点的选择方法，如果想要获取它们的一些信息，比如文本、属性等，也用同样的方法，示例如下：</p><pre class=" language-python"><code class="language-python">html <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;html>    &lt;body>        &lt;p class="story">            Once upon a time there were three little sisters; and their names were            &lt;a href="http://example.com/elsie" class="sister" id="link1">Bob&lt;/a>&lt;a href="http://example.com/lacie" class="sister" id="link2">Lacie&lt;/a>         &lt;/p>"""</span><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Next Sibling:'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>a<span class="token punctuation">.</span>next_sibling<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>a<span class="token punctuation">.</span>next_sibling<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>a<span class="token punctuation">.</span>next_sibling<span class="token punctuation">.</span>string<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Parent:'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>a<span class="token punctuation">.</span>parents<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>a<span class="token punctuation">.</span>parents<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>a<span class="token punctuation">.</span>parents<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'class'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class=" language-python"><code class="language-python">Next Sibling<span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bs4.element.Tag'</span><span class="token operator">></span><span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sister"</span> href<span class="token operator">=</span><span class="token string">"http://example.com/lacie"</span> id<span class="token operator">=</span><span class="token string">"link2"</span><span class="token operator">></span>Lacie<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>LacieParent<span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'generator'</span><span class="token operator">></span><span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"story"</span><span class="token operator">></span>            Once upon a time there were three little sisters<span class="token punctuation">;</span> <span class="token operator">and</span> their names were            <span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sister"</span> href<span class="token operator">=</span><span class="token string">"http://example.com/elsie"</span> id<span class="token operator">=</span><span class="token string">"link1"</span><span class="token operator">></span>Bob<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sister"</span> href<span class="token operator">=</span><span class="token string">"http://example.com/lacie"</span> id<span class="token operator">=</span><span class="token string">"link2"</span><span class="token operator">></span>Lacie<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">[</span><span class="token string">'story'</span><span class="token punctuation">]</span></code></pre><p>如果返回结果是单个节点，那么可以直接调用 string、attrs 等属性获得其文本和属性；如果返回结果是多个节点的生成器，则可以转为列表后取出某个元素，然后再调用 string、attrs 等属性获取其对应节点的文本和属性。</p><h3 id="6-方法选择器"><a href="#6-方法选择器" class="headerlink" title="6. 方法选择器"></a>6. 方法选择器</h3><p>前面所讲的选择方法都是通过属性来选择的，这种方法非常快，但是如果进行比较复杂的选择的话，它就比较烦琐，不够灵活了。幸好，Beautiful Soup 还为我们提供了一些查询方法，比如 find_all 和 find 等，调用它们，然后传入相应的参数，就可以灵活查询了。</p><h4 id="find-all"><a href="#find-all" class="headerlink" title="find_all"></a>find_all</h4><p>find_all，顾名思义，就是查询所有符合条件的元素，可以给它传入一些属性或文本来得到符合条件的元素，功能十分强大。</p><p>它的 API 如下：</p><pre class=" language-python"><code class="language-python">find_all<span class="token punctuation">(</span>name <span class="token punctuation">,</span> attrs <span class="token punctuation">,</span> recursive <span class="token punctuation">,</span> text <span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span></code></pre><h5 id="name"><a href="#name" class="headerlink" title="name"></a>name</h5><p>我们可以根据节点名来查询元素，下面我们用一个实例来感受一下：</p><pre class=" language-python"><code class="language-python">html<span class="token operator">=</span><span class="token triple-quoted-string string">'''&lt;div class="panel">    &lt;div class="panel-heading">        &lt;h4>Hello&lt;/h4>    &lt;/div>    &lt;div class="panel-body">        &lt;ul class="list" id="list-1">            &lt;li class="element">Foo&lt;/li>            &lt;li class="element">Bar&lt;/li>            &lt;li class="element">Jay&lt;/li>        &lt;/ul>        &lt;ul class="list list-small" id="list-2">            &lt;li class="element">Foo&lt;/li>            &lt;li class="element">Bar&lt;/li>        &lt;/ul>    &lt;/div>&lt;/div>'''</span><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class=" language-python"><code class="language-python"><span class="token punctuation">[</span><span class="token operator">&lt;</span>ul <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"list"</span> id<span class="token operator">=</span><span class="token string">"list-1"</span><span class="token operator">></span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Foo<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Bar<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Jay<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>ul <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"list list-small"</span> id<span class="token operator">=</span><span class="token string">"list-2"</span><span class="token operator">></span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Foo<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Bar<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bs4.element.Tag'</span><span class="token operator">></span></code></pre><p>这里我们调用了 find_all 方法，传入 name 参数，其参数值为 ul。也就是说，我们想要查询所有 ul 节点，返回结果是列表类型，长度为 2，每个元素依然都是 bs4.element.Tag 类型。</p><p>因为都是 Tag 类型，所以依然可以进行嵌套查询。还是同样的文本，这里查询出所有 ul 节点后，再继续查询其内部的 li 节点：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> ul <span class="token keyword">in</span> soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ul<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre class=" language-python"><code class="language-python"><span class="token punctuation">[</span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Foo<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Bar<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Jay<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Foo<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Bar<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">]</span></code></pre><p>返回结果是列表类型，列表中的每个元素依然还是 Tag 类型。</p><p>接下来我们就可以遍历每个 li 获取它的文本了。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> ul <span class="token keyword">in</span> soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ul<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> li <span class="token keyword">in</span> ul<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">.</span>string<span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre class=" language-python"><code class="language-python"><span class="token punctuation">[</span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Foo<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Bar<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Jay<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">]</span>FooBarJay<span class="token punctuation">[</span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Foo<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Bar<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">]</span>FooBar</code></pre><h5 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h5><p>除了根据节点名查询，我们也可以传入一些属性来进行查询，我们用一个实例感受一下：</p><pre class=" language-python"><code class="language-python">html<span class="token operator">=</span><span class="token triple-quoted-string string">'''&lt;div class="panel">    &lt;div class="panel-heading">        &lt;h4>Hello&lt;/h4>    &lt;/div>    &lt;div class="panel-body">        &lt;ul class="list" id="list-1" name="elements">            &lt;li class="element">Foo&lt;/li>            &lt;li class="element">Bar&lt;/li>            &lt;li class="element">Jay&lt;/li>        &lt;/ul>        &lt;ul class="list list-small" id="list-2">            &lt;li class="element">Foo&lt;/li>            &lt;li class="element">Bar&lt;/li>        &lt;/ul>    &lt;/div>&lt;/div>'''</span><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span>attrs<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;'id': 'list-1'&amp;#125;))</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span>attrs<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;'name': 'elements'&amp;#125;))</span></code></pre><p>运行结果：</p><pre><code>[&lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt;&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;&lt;/ul&gt;][&lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt;&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;&lt;/ul&gt;]</code></pre><p>这里查询的时候传入的是 attrs 参数，参数的类型是字典类型。比如，要查询 id 为 list-1 的节点，可以传入 attrs={‘id’: ‘list-1’} 的查询条件，得到的结果是列表形式，包含的内容就是符合 id 为 list-1 的所有节点。在上面的例子中，符合条件的元素个数是 1，所以结果是长度为 1 的列表。</p><p>对于一些常用的属性，比如 id 和 class 等，我们可以不用 attrs 来传递。比如，要查询 id 为 list-1 的节点，可以直接传入 id 这个参数。还是上面的文本，我们换一种方式来查询：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span>id<span class="token operator">=</span><span class="token string">'list-1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span>class_<span class="token operator">=</span><span class="token string">'element'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre class=" language-python"><code class="language-python"><span class="token punctuation">[</span><span class="token operator">&lt;</span>ul <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"list"</span> id<span class="token operator">=</span><span class="token string">"list-1"</span><span class="token operator">></span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Foo<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Bar<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Jay<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Foo<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Bar<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Jay<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Foo<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Bar<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">]</span></code></pre><p>这里直接传入 id=’list-1’，就可以查询 id 为 list-1 的节点元素了。而对于 class 来说，由于 class 在 Python 里是一个关键字，所以后面需要加一个下划线，即 class_=’element’，返回的结果依然还是 Tag 组成的列表。</p><h5 id="text"><a href="#text" class="headerlink" title="text"></a>text</h5><p>text 参数可用来匹配节点的文本，传入的形式可以是字符串，可以是正则表达式对象，示例如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> rehtml<span class="token operator">=</span><span class="token triple-quoted-string string">'''&lt;div class="panel">    &lt;div class="panel-body">        &lt;a>Hello, this is a link&lt;/a>        &lt;a>Hello, this is a link, too&lt;/a>    &lt;/div>&lt;/div>'''</span><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span>text<span class="token operator">=</span>re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span><span class="token string">'link'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class=" language-python"><code class="language-python"><span class="token punctuation">[</span><span class="token string">'Hello, this is a link'</span><span class="token punctuation">,</span> <span class="token string">'Hello, this is a link, too'</span><span class="token punctuation">]</span></code></pre><p>这里有两个 a 节点，其内部包含文本信息。这里在 find_all() 方法中传入 text 参数，该参数为正则表达式对象，结果返回所有匹配正则表达式的节点文本组成的列表。</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>除了 find_all 方法，还有 find 方法，只不过 find 方法返回的是单个元素，也就是第一个匹配的元素，而 find_all 返回的是所有匹配的元素组成的列表。示例如下：</p><pre class=" language-python"><code class="language-python">html<span class="token operator">=</span><span class="token triple-quoted-string string">'''&lt;div class="panel">    &lt;div class="panel-heading">        &lt;h4>Hello&lt;/h4>    &lt;/div>    &lt;div class="panel-body">        &lt;ul class="list" id="list-1">            &lt;li class="element">Foo&lt;/li>            &lt;li class="element">Bar&lt;/li>            &lt;li class="element">Jay&lt;/li>        &lt;/ul>        &lt;ul class="list list-small" id="list-2">            &lt;li class="element">Foo&lt;/li>            &lt;li class="element">Bar&lt;/li>        &lt;/ul>    &lt;/div>&lt;/div>'''</span><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>find<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>find<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>find<span class="token punctuation">(</span>class_<span class="token operator">=</span><span class="token string">'list'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre><code>&lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;&lt;/ul&gt;&lt;class &#39;bs4.element.Tag&#39;&gt;&lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;&lt;/ul&gt;</code></pre><p>返回结果不再是列表形式，而是第一个匹配的节点元素，类型依然是 Tag 类型。</p><p>另外还有许多的查询方法，用法与前面介绍的 find_all、find 方法完全相同，只不过查询范围不同，在此做一下简单的说明。</p><p>find_parents 和 find_parent：前者返回所有祖先节点，后者返回直接父节点。</p><p>find_next_siblings 和 find_next_sibling：前者返回后面所有的兄弟节点，后者返回后面第一个兄弟节点。</p><p>find_previous_siblings 和 find_previous_sibling：前者返回前面所有的兄弟节点，后者返回前面第一个兄弟节点。</p><p>find_all_next 和 find_next：前者返回节点后所有符合条件的节点，后者返回第一个符合条件的节点。</p><p>find_all_previous 和 find_previous：前者返回节点前所有符合条件的节点，后者返回第一个符合条件的节点。</p><h3 id="7-CSS-选择器"><a href="#7-CSS-选择器" class="headerlink" title="7. CSS 选择器"></a>7. CSS 选择器</h3><p>Beautiful Soup 还提供了另外一种选择器，那就是 CSS 选择器。如果对 Web 开发熟悉的话，那么对 CSS 选择器肯定也不陌生。如果不熟悉的话，可以参考 <a href="http://www.w3school.com.cn/cssref/css_selectors.asp">http://www.w3school.com.cn/cssref/css_selectors.asp</a> 了解。</p><p>使用 CSS 选择器，只需要调用 select 方法，传入相应的 CSS 选择器即可，我们用一个实例来感受一下：</p><pre class=" language-python"><code class="language-python">html<span class="token operator">=</span><span class="token triple-quoted-string string">'''&lt;div class="panel">    &lt;div class="panel-heading">        &lt;h4>Hello&lt;/h4>    &lt;/div>    &lt;div class="panel-body">        &lt;ul class="list" id="list-1">            &lt;li class="element">Foo&lt;/li>            &lt;li class="element">Bar&lt;/li>            &lt;li class="element">Jay&lt;/li>        &lt;/ul>        &lt;ul class="list list-small" id="list-2">            &lt;li class="element">Foo&lt;/li>            &lt;li class="element">Bar&lt;/li>        &lt;/ul>    &lt;/div>&lt;/div>'''</span><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.panel .panel-heading'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'ul li'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'#list-2 .element'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre class=" language-python"><code class="language-python"><span class="token punctuation">[</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"panel-heading"</span><span class="token operator">></span><span class="token operator">&lt;</span>h4<span class="token operator">></span>Hello<span class="token operator">&lt;</span><span class="token operator">/</span>h4<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Foo<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Bar<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Jay<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Foo<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Bar<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Foo<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Bar<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bs4.element.Tag'</span><span class="token operator">></span></code></pre><p>这里我们用了 3 次 CSS 选择器，返回的结果均是符合 CSS 选择器的节点组成的列表。例如，select(‘ul li’) 则是选择所有 ul 节点下面的所有 li 节点，结果便是所有的 li 节点组成的列表。</p><p>最后一句我们打印输出了列表中元素的类型，可以看到类型依然是 Tag 类型。</p><h4 id="嵌套选择-1"><a href="#嵌套选择-1" class="headerlink" title="嵌套选择"></a>嵌套选择</h4><p>select 方法同样支持嵌套选择，例如我们先选择所有 ul 节点，再遍历每个 ul 节点选择其 li 节点，样例如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">for</span> ul <span class="token keyword">in</span> soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ul<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre class=" language-python"><code class="language-python"><span class="token punctuation">[</span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Foo<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Bar<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Jay<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Foo<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"element"</span><span class="token operator">></span>Bar<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">]</span></code></pre><p>可以看到正常输出了遍历每个 ul 节点之后，其下的所有 li 节点组成的列表。</p><h4 id="获取属性-1"><a href="#获取属性-1" class="headerlink" title="获取属性"></a>获取属性</h4><p>我们知道节点类型是 Tag 类型，所以获取属性还可以用原来的方法。仍然是上面的 HTML 文本，这里尝试获取每个 ul 节点的 id 属性：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">for</span> ul <span class="token keyword">in</span> soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ul<span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ul<span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>运行结果如下：</p><pre><code>list-1list-1list-2list-2</code></pre><p>可以看到直接传入中括号和属性名和通过 attrs 属性获取属性值都是可以成功的。</p><h4 id="获取文本"><a href="#获取文本" class="headerlink" title="获取文本"></a>获取文本</h4><p>要获取文本，当然也可以用前面所讲的 string 属性。此外，还有一个方法，那就是 get_text，示例如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span><span class="token keyword">for</span> li <span class="token keyword">in</span> soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Get Text:'</span><span class="token punctuation">,</span> li<span class="token punctuation">.</span>get_text<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'String:'</span><span class="token punctuation">,</span> li<span class="token punctuation">.</span>string<span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class=" language-python"><code class="language-python">Get Text<span class="token punctuation">:</span> FooString<span class="token punctuation">:</span> FooGet Text<span class="token punctuation">:</span> BarString<span class="token punctuation">:</span> BarGet Text<span class="token punctuation">:</span> JayString<span class="token punctuation">:</span> JayGet Text<span class="token punctuation">:</span> FooString<span class="token punctuation">:</span> FooGet Text<span class="token punctuation">:</span> BarString<span class="token punctuation">:</span> Bar</code></pre><p>二者的效果是完全一致的，都可以获取到节点的文本值。</p><h3 id="8-结语"><a href="#8-结语" class="headerlink" title="8. 结语"></a>8. 结语</h3><p>到此 BeautifulSoup 的使用介绍基本就结束了，最后做一下简单的总结：</p><ul><li>推荐使用 LXML 解析库，必要时使用 html.parser。</li><li>节点选择筛选功能弱但是速度快。</li><li>建议使用 find、find_all 方法查询匹配单个结果或者多个结果。</li><li>如果对 CSS 选择器熟悉的话可以使用 select 选择法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python3WebSpider </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BeartifulSoup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql数据库</title>
      <link href="/post/8465.html"/>
      <url>/post/8465.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、数据库基本介绍"><a href="#一、数据库基本介绍" class="headerlink" title="一、数据库基本介绍"></a>一、数据库基本介绍</h3><blockquote><p>目标：了解数据库的概念和数据库的作用</p></blockquote><ul><li>数据库基本知识</li><li>数据库分类</li><li>SQL简介</li><li>MySQL访问</li></ul><h4 id="1、数据库基本知识"><a href="#1、数据库基本知识" class="headerlink" title="1、数据库基本知识"></a>1、数据库基本知识</h4><blockquote><p>目标：了解数据库的概念和数据库的作用</p></blockquote><blockquote><p>概念</p></blockquote><p><strong>数据库</strong>：database，是一种存储数据的仓库</p><ul><li>数据库是根据数据结构组织、存储和管理数据</li><li>数据库能够长期、高效的管理和存储数据</li><li>数据库的目的就是能够存储（写）和提供（读）数据</li></ul><h4 id="2、数据库分类：根据数据库的架构和数据组织原理进行分类"><a href="#2、数据库分类：根据数据库的架构和数据组织原理进行分类" class="headerlink" title="2、数据库分类：根据数据库的架构和数据组织原理进行分类"></a>2、数据库分类：根据数据库的架构和数据组织原理进行分类</h4><p>1、早期根据数据库的组织数据的存储模型分类</p><ul><li>层次数据库：基于层次的数据结构（数据分层）</li><li>网状数据库：基于网状的数据结构（数据网络）</li><li>关系数据库：基于关系模型的数据结构（二维表）</li></ul><p>2、现在较多根据实际数据管理模型分类（存储介质）</p><ul><li>关系型数据库：基于关系模型的数据结构（二维表）                      <strong>通常存储在磁盘</strong></li><li>非关系型数据库：没有具体模型的数据结构（键值对）                  <strong>通常存储在内存</strong></li></ul><p><strong>3、关系型数据库</strong></p><blockquote><p>目标：了解关系型数据库的模型逻辑，了解当前流行的关系型数据库产品</p></blockquote><p><strong>关系型数据库</strong>：是一种建立在关系模型上的数据库</p><ul><li><p>关系模型</p><ul><li>关系数据结构（存储）</li><li>关系操作集合（操作）</li><li>关系完整性约束（约束）</li></ul></li><li><p>关系型数据库存储在磁盘中（永久性存储）</p></li><li><p>关系型数据库系统（DBS）模型有四层结构</p><ul><li>数据库管理系统（DBMS）：管理系统运行</li><li>数据库（DB）：数据库存储的管理者</li><li>数据表（Table）：数据关系管理者</li><li>数据字段（Field）：实际数据存储者</li></ul></li><li><p>关系型数据库产品</p><ul><li>大型：Oracle、DB2</li><li>中型：MySQL、SqlServer</li></ul></li></ul><h4 id="4、非关系型数据库"><a href="#4、非关系型数据库" class="headerlink" title="4、非关系型数据库"></a>4、非关系型数据库</h4><blockquote><p>目标：了解非关系型数据库的概念和一些主流产品</p></blockquote><p><strong>非关系型数据库</strong>：NoSQL，不仅仅是关系型数据库</p><ul><li>所有不是关系型数据库的统称</li><li>数据存储模型不是二维表，而是键值对（key-&gt;value）</li><li>存储的位置通常是内存（效率高）</li><li>不能永久性存储（需要定时存到关系型数据库中）</li><li>常见的非关系型数据库产品<ul><li>MongoDB</li><li>Redis</li><li>Memcached</li></ul></li></ul><blockquote><p>对比</p></blockquote><p>NoSQL通常是与关系型数据库配合使用的，他们彼此是一种互补关系</p><ul><li>NoSQL运行在内存，解决效率问题<ul><li>I/O问题</li><li>效率问题</li></ul></li><li>MySQL运行在磁盘，解决稳定问题<ul><li>安全问题（永久存储）</li><li>稳定</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/post/7056.html"/>
      <url>/post/7056.html</url>
      
        <content type="html"><![CDATA[<h4 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h4><p><strong>计算机网络</strong>：是一个将分散的、具有独立功能的<strong>计算机系统</strong>，通过<strong>通信设备</strong>与<strong>线路</strong>连接起来，由功能完善的<strong>软件</strong>实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统</p><h4 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h4><ul><li><p>数据通信（连通性）</p></li><li><p>资源共享 </p><ul><li>硬件、软件、数据</li></ul></li><li><p>分布式处理 </p><ul><li>多台计算机各自承担同一工作任务的不同部分 <strong>Hadoop平台</strong></li></ul></li><li><p>提高可靠性（替代机）</p></li><li><p>负载均衡 </p><ul><li>各计算机之间更亲密，分布式处理使每台计算机工作更加合理</li></ul></li></ul><h4 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h4><p><strong>1. 组成部分</strong> 硬件、软件、协议</p><p>2.工作方式</p><ul><li>边缘部分：用户直接使用（主机间通信的地方）<ul><li>c/s    方式</li><li>p2p 方式</li></ul></li><li>核心部分：为边缘部分服务<ul><li>路由器、网络等组成</li></ul></li></ul><p>3.功能组成</p><ul><li><strong>通信子网</strong> 实现数据通信 <strong>之后在网络进行通信</strong></li><li><strong>资源子网</strong> 实现资源共享/数据处理  <strong>先在主机中进行操作</strong></li></ul><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924195753547.png" alt="image-20200924195753547"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>人工智能</title>
      <link href="/post/6764.html"/>
      <url>/post/6764.html</url>
      
        <content type="html"><![CDATA[<h4 id="问题求解系统"><a href="#问题求解系统" class="headerlink" title="问题求解系统"></a>问题求解系统</h4><ul><li><p>依靠<font color='red'>搜索技术</font>解决问题</p><ul><li>缺乏针对性</li><li>效率低</li></ul></li><li><p>依靠<font color='red'>推理技术</font>解决问题</p><ul><li>目标明确</li><li>效率高</li></ul></li><li><p>在人工智能中，搜索问题一般包括两个重要的问题：</p><ul><li>搜什么</li><li>在哪里搜</li></ul></li></ul><h4 id="状态空间的构成"><a href="#状态空间的构成" class="headerlink" title="状态空间的构成"></a>状态空间的构成</h4><ul><li>状态</li><li>算符</li><li>状态空间：由表示一个问题的全部状态及一切可用算符构成的集合称为该问题的状态空间。</li><li>问题的解：从问题的初始状态集S出发，经过一系列的算符运算，到达目标状态</li></ul>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-net</title>
      <link href="/post/5a45.html"/>
      <url>/post/5a45.html</url>
      
        <content type="html"><![CDATA[<h4 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h4><blockquote><p>测试</p></blockquote><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924105716806.png" alt="image-20200924105716806"></p><pre class=" language-shell"><code class="language-shell">#运行容器[root@iZuf6iu3l09b01ael17tbrZ ~]# docker run -d -P --name tomcat01 tomcat[root@iZuf6iu3l09b01ael17tbrZ ~]# docker run -d -P --name tomcat02 tomcat#查看容器内的ip地址ip addr</code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924141629950.png" alt="image-20200924141629950"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924142012742.png" alt="image-20200924141832008"></p><pre class=" language-shell"><code class="language-shell">#宿主机可以ping通docker容器内部[root@iZuf6iu3l09b01ael17tbrZ ~]# ping 172.17.0.2[root@iZuf6iu3l09b01ael17tbrZ ~]# ping 172.17.0.3</code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924142246847.png" alt="image-20200924142246847"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924142315011.png" alt="image-20200924142315011"></p><blockquote><p>原理：</p><p>1、我们每启动一个dockers容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0桥接模式，使用的技术时veth-pair技术！</p><p>2、每次启动一个容器测试，就会发现多了一对网卡</p><p>3、只要容器删除，对应网桥一对就没了</p><p><a href="https://www.cnblogs.com/bakari/p/10613710.html">https://www.cnblogs.com/bakari/p/10613710.html</a></p></blockquote><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924143001546.png" alt="image-20200924143001546"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924152318914.png" alt="image-20200924152318914"></p><h4 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h4><p><strong>tomcat03 可以不需要ping tomcat的内网地址，ping tomcat02即可</strong></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924153106164.png" alt="image-20200924153106164"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924153916628.png" alt="image-20200924153916628"></p><h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><blockquote><p>查看所有的docker网络</p></blockquote><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924154044323.png" alt="image-20200924154044323"></p><h5 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h5><ul><li>bridge： 桥接docker默认</li><li>mone：  不配置网络</li><li>host:        和宿主机共享网络</li><li>container： 容器网络连通！ （用的少！局限很大）</li></ul><pre class=" language-shell"><code class="language-shell"># 我们直接启动的命令 --net bridge（默认不写就是这个）,而这个就是我们的docker0[root@iZuf6iu3l09b01ael17tbrZ ~]# dokcer run -d -P --name tomcat01 --net bridge tomcat# docker0特点，默认，域名不能访问， --link可以打通连接！# 我们可以自定义一个网络[root@iZuf6iu3l09b01ael17tbrZ ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet# subnet  子网地址# gateway 网关</code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924154844906.png" alt="image-20200924154844906"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924155127112.png" alt="image-20200924155127112"></p><p><strong>注意 ：自己自定义create的网络可以直接ping名字</strong></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924155225214.png" alt="image-20200924155225214"></p><h4 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h4><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924160109879.png" alt="image-20200924160109879"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile</title>
      <link href="/post/4924.html"/>
      <url>/post/4924.html</url>
      
        <content type="html"><![CDATA[<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><pre class=" language-shell"><code class="language-shell">mkdir docker-test-volume && cd docker-test-volumevim dockerfileFROM centosVOLUME ["volume01","volume02"]CMD echo "-----------end------------"CMD /bin/bash# build自己的镜像docker build -f dockerfile -t shenhao/centos:1.0 .-f :file文件-t :增加名字的tag</code></pre><h3 id="容器间互联，同一个数据卷："><a href="#容器间互联，同一个数据卷：" class="headerlink" title="容器间互联，同一个数据卷："></a>容器间互联，同一个数据卷：</h3><pre class=" language-shell"><code class="language-shell">docker run -it --name docker02 --volumes-from docker01 shenhao/centos:1.0</code></pre><pre class=" language-shell"><code class="language-shell"># 测试，可以删除docker01,查看一下docker02和docker03是否还可以访问这个文件# 测试依旧可以访问,因为映射到宿主机同一个位置</code></pre><h3 id="DockerFile的指令"><a href="#DockerFile的指令" class="headerlink" title="DockerFile的指令"></a>DockerFile的指令</h3><pre class=" language-shell"><code class="language-shell">FROM         # 基础镜像MAINTAINER     # 镜像是谁写的，姓名+邮箱RUN             # 镜像构建的时候需要运行的命令ADD             # 步骤：tomcat镜像WORKDIE         # 镜像的工作目录VOLUME         # 挂载的目录EXPOSE         # 保留的端口配置,暴露容器内的端口CMD          # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代ENTRYPOINT     # 指定这个容器启动的时候要运行的命令，可以追加命令ONBUILD      # 当构建一个被继承DockerFile 这个时候就会运行ONBUILD的指令。COPY         # 类似ADD，将我们文件拷贝到镜像ENV          # 构建的时候设置环境变量！</code></pre><h5 id="1-实战：构建自己的centos"><a href="#1-实战：构建自己的centos" class="headerlink" title="1. 实战：构建自己的centos"></a>1. 实战：构建自己的centos</h5><pre class=" language-shell"><code class="language-shell"># 1.编写DockerFile的文件vim mydockerfile-centosFROM centosMAINTAINER shenhao<56550322@163.com>ENV MYPATH /user/local #键值对的形式WORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo "---end---"CMD /bin/bash# 2.通过mydockerfile这个文件构建镜像，镜像名为mycentosdocker build -f mydockerfile-centos -t mycentos:2.0 .</code></pre><h5 id="2-查看并运行自己build的镜像"><a href="#2-查看并运行自己build的镜像" class="headerlink" title="2. 查看并运行自己build的镜像"></a>2. 查看并运行自己build的镜像</h5><h6 id="2-1-查看镜像"><a href="#2-1-查看镜像" class="headerlink" title="2.1 查看镜像"></a>2.1 查看镜像</h6><pre class=" language-shell"><code class="language-shell">docker images</code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/image-20200923171635842.png" alt="image-20200923171635842"></p><h6 id="2-2-运行镜像"><a href="#2-2-运行镜像" class="headerlink" title="2.2 运行镜像"></a>2.2 运行镜像</h6><pre class=" language-shell"><code class="language-shell">#运行镜像，形成容器docker run -it --name complete_centos mycentos:2.0 /bin/bash#查看容器docker ps</code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/image-20200923215347952.png" alt="image-20200923215347952"></p><h6 id="2-3-执行新的命令"><a href="#2-3-执行新的命令" class="headerlink" title="2.3 执行新的命令"></a>2.3 执行新的命令</h6><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/image-20200923215635142.png" alt="image-20200923215635142"></p><blockquote><p>列出镜像变更的历史</p><ul><li>通过docker history [镜像名:tag] 或者docker history 镜像ID</li></ul><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/image-20200923215856846.png" alt="image-20200923215856846"></p></blockquote><h5 id="3-CMD和ENTRYPOINT的区别"><a href="#3-CMD和ENTRYPOINT的区别" class="headerlink" title="3. CMD和ENTRYPOINT的区别"></a>3. CMD和ENTRYPOINT的区别</h5><pre class=" language-shell"><code class="language-shell">#编写dockerfile文件FROM centosCMD ["ls","-a"]</code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/image-20200923220821564.png" alt="image-20200923220821564"></p><pre class=" language-shell"><code class="language-shell">#构建镜像docker build -f docker-cmd-test -t cmd-ls:2.0 .#运行镜像docker run -it --name cmd cmd-ls:2.0</code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/image-20200923221257872.png" alt="image-20200923221257872"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/image-20200923221424647.png" alt="image-20200923221424647"></p><p><strong>docker运行的替代指令必须是完整的指令</strong>&lt;必须在run的时候写出完整的shell命令&gt;</p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200923222258930.png" alt="image-20200923222258930"></p><p><strong>测试ENTRYPOINT</strong>&lt;可以在run的时候直接-a&gt;</p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200923223038230.png" alt="image-20200923223038230"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-202009232236136901.png" alt="image-20200923223613690"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200923223527647.png" alt="image-20200923223527647"></p><h3 id="实战：Tomcat镜像"><a href="#实战：Tomcat镜像" class="headerlink" title="实战：Tomcat镜像"></a>实战：Tomcat镜像</h3><pre class=" language-shell"><code class="language-shell">FROM centosMAINTAINER shenhao<56550322@163.com>COPY readme.txt /usr/local/readme.txt #将宿主机上的readme.txt文件copy到容器内的/usr/local/readme.txt# 增加层数ADD jdk.tar.gz /usr/local  #ADD命令会自动解压ADD apache-tomcat.tar.gz /usr/localRUN yum -y install vim# 配置环境变量ENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_11ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.22ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.22ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.22/bin/startup.sh && tail -F /usr/local/apache-tomcat-9.0.22/bin/logs.catalina.out</code></pre><p><strong>注意：如果dockefile的文件名是Dockerfile，可以在docker build时不需要-f参数</strong></p><h4 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h4><ul><li><strong>通过dockerhub上传镜像</strong></li></ul><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924002648584.png" alt="image-20200924002648584"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924004034598.png" alt="image-20200924004034598"></p><p><strong>在上传的时候必须要重新tag命名！！！</strong></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924004216020.png" alt="image-20200924004216020"></p><ul><li><strong>通过阿里云上传镜像</strong></li></ul><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924004539333.png" alt="image-20200924004539333"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924004626226.png" alt="image-20200924004626226"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924004655267.png" alt="image-20200924004655267"></p><h4 id="1-登录阿里云Docker-Registry"><a href="#1-登录阿里云Docker-Registry" class="headerlink" title="1. 登录阿里云Docker Registry"></a>1. 登录阿里云Docker Registry</h4><pre><code>$ sudo docker login --username=tyj_ecust registry.cn-shanghai.aliyuncs.com</code></pre><p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。</p><p>您可以在访问凭证页面修改凭证密码。</p><h4 id="2-从Registry中拉取镜像"><a href="#2-从Registry中拉取镜像" class="headerlink" title="2. 从Registry中拉取镜像"></a>2. 从Registry中拉取镜像</h4><pre><code>$ sudo docker pull registry.cn-shanghai.aliyuncs.com/shenhao-stu-test/shenhao-test:[镜像版本号]</code></pre><h4 id="3-将镜像推送到Registry"><a href="#3-将镜像推送到Registry" class="headerlink" title="3. 将镜像推送到Registry"></a>3. 将镜像推送到Registry</h4><pre><code>sudo docker login --username=tyj_ecust registry.cn-shanghai.aliyuncs.comsudo docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/shenhao-stu-test/shenhao-test:[镜像版本号]sudo docker push registry.cn-shanghai.aliyuncs.com/shenhao-stu-test/shenhao-test:[镜像版本号]</code></pre><p>请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</p><h4 id="4-选择合适的镜像仓库地址"><a href="#4-选择合适的镜像仓库地址" class="headerlink" title="4. 选择合适的镜像仓库地址"></a>4. 选择合适的镜像仓库地址</h4><p>从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。</p><p>如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-shanghai.aliyuncs.com 作为Registry的域名登录。</p><h4 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h4><p>使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。使用 “docker push” 命令将该镜像推送至远程。</p><pre><code>$ sudo docker push registry.cn-shanghai.aliyuncs.com/shenhao-stu-test/shenhao-test:1.0</code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924005537136.png" alt="image-20200924005537136"></p><h4 id="6-查看"><a href="#6-查看" class="headerlink" title="6. 查看"></a>6. 查看</h4><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Other/image-20200924140501463.png" alt="image-20200924140501463"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R</title>
      <link href="/post/fd81.html"/>
      <url>/post/fd81.html</url>
      
        <content type="html"><![CDATA[<h3 id="R-语言语法"><a href="#R-语言语法" class="headerlink" title="R 语言语法"></a>R 语言语法</h3><blockquote><ol><li>查看当前目录 getwd()</li><li>切换指定目录 setwd()</li></ol></blockquote><h4 id="1-Subsetting-data选取数据"><a href="#1-Subsetting-data选取数据" class="headerlink" title="1. Subsetting data选取数据"></a>1. Subsetting data选取数据</h4><pre class=" language-R"><code class="language-R">student[student$gender=='Female']</code></pre><pre class=" language-R"><code class="language-R">attach(student)grade[Chinese>80,]grade[Chinese>80 & Math>80,]grade[Chinese>80 | Math>80,]detach]</code></pre><h4 id="2-Sorting-data"><a href="#2-Sorting-data" class="headerlink" title="2. Sorting data"></a>2. Sorting data</h4><pre class=" language-R"><code class="language-R"># sort by Chinese ascorder(grade$Chinese) # 排出升序的行号oder(-grade$Chinese) # 进行降序的行号grade[order(grade$Chinese),] #升序排序的dataFrame</code></pre><pre class=" language-R"><code class="language-R"># or use attachattach(grade)# sort by Chinese ascgrade[order(Chinese),]# sort by Chinese asc, English desgrade[order(Chinese,-English),]detach(grade)]</code></pre><h4 id="3-Merging-data"><a href="#3-Merging-data" class="headerlink" title="3. Merging data"></a>3. Merging data</h4><pre class=" language-R"><code class="language-R"># merging data by giving column namestotal <- merge(student,grade,by="name")head(total)</code></pre><h4 id="4-Aggregating-Data"><a href="#4-Aggregating-Data" class="headerlink" title="4. Aggregating Data"></a>4. Aggregating Data</h4><ul><li>aggregate(formula,data,FUN)</li></ul><pre class=" language-R"><code class="language-R"># compute the average Math grade by classaggregate(Math~class, data=total,FUN=mean)# compute the average grade by class and genderaggregate(cbind(Chinese,Math,English,Science)~class+gender,data=total,FUN=mean)</code></pre><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>paste(a,b,c) # 将所有内容组合出来，以sep=“ ”为分割</p><h4 id="5-自定义函数"><a href="#5-自定义函数" class="headerlink" title="5. 自定义函数"></a>5. 自定义函数</h4><h5 id="Define-a-function"><a href="#Define-a-function" class="headerlink" title="Define a function:"></a>Define a function:</h5><pre class=" language-R"><code class="language-R">function_name <- function (<arguments>)&#123;    ## Do something interesting     return(result)&#125; </code></pre>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to use docker</title>
      <link href="/post/f0df.html"/>
      <url>/post/f0df.html</url>
      
        <content type="html"><![CDATA[<h3 id="前提详述：安装Docker"><a href="#前提详述：安装Docker" class="headerlink" title="前提详述：安装Docker"></a>前提详述：安装Docker</h3><ul><li><p>环境准备</p><p>Linux要求内核3.0以上</p></li></ul><p>安装</p><pre><code>➜ ~ uname -r 4.15.0-96-generic # 要求3.0以上 ➜ ~ cat /etc/os-release NAME=&quot;Ubuntu&quot; VERSION=&quot;18.04.4 LTS (Bionic Beaver)&quot; ID=ubuntu ID_LIKE=debian PRETTY_NAME=&quot;Ubuntu 18.04.4 LTS&quot; VERSION_ID=&quot;18.04&quot; HOME_URL=&quot;https://www.ubuntu.com/&quot; SUPPORT_URL=&quot;https://help.ubuntu.com/&quot; BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot; PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy- policy&quot;VERSION_CODENAME=bionic UBUNTU_CODENAME=bionic</code></pre><ul><li>安装</li></ul><blockquote><p>帮助文档：<a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a> </p></blockquote><pre><code>#1.卸载旧版本 yum remove docker \docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine #2.需要的安装包 yum install -y yum-utils #3.设置镜像的仓库 yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo #默认是从国外的，不推荐 #推荐使用国内的 yum-config-manager \ --add-repo \ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #更新yum软件包索引 yum makecache fast #4.安装docker相关的 docker-ce 社区版 而ee是企业版 yum install docker-ce docker-ce-cli containerd.io #6. 使用docker version查看是否按照成功 docker version #7. 测试 docker run hello-world </code></pre><pre><code>#1. 卸载依赖 yum remove docker-ce docker-ce-cli containerd.io #2. 删除资源 rm -rf /var/lib/docker # /var/lib/docker 是docker的默认工作路径！</code></pre><ul><li><p>阿里云镜像加速</p><p>1、登录阿里云找到容器服务</p><p>2、找到镜像加速器</p></li></ul><hr><h2 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h2><h3 id="1-启动容器"><a href="#1-启动容器" class="headerlink" title="1. 启动容器"></a>1. 启动容器</h3><p>以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：</p><pre><code>$ docker run -it ubuntu /bin/bash</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2016/05/docker-container-run.png" alt="img"></p><p>参数说明：</p><ul><li><strong>-i</strong>: 交互式操作。</li><li><strong>-t</strong>: 终端。</li><li><strong>ubuntu</strong>: ubuntu 镜像。</li><li><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li></ul><p>要退出终端，直接输入 <strong>exit</strong>:</p><pre><code>root@ed09e4490c57:/# exit</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2016/05/docker-container-exit.png" alt="img"></p><h3 id="2-启动已停止运行的容器"><a href="#2-启动已停止运行的容器" class="headerlink" title="2.启动已停止运行的容器"></a>2.启动已停止运行的容器</h3><p>查看所有的容器命令如下：</p><pre><code>$ docker ps -a</code></pre><p>点击图片查看大图：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/05/docker-container-psa.png"><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/docker-stop-2.png" alt="img"></a></p><p>使用 docker start 启动一个已停止的容器：</p><pre><code>$ docker start b750bbbcfd88 </code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/docker-stop-2.png" alt="img"></p><h3 id="3-后台运行"><a href="#3-后台运行" class="headerlink" title="3. 后台运行"></a>3. 后台运行</h3><p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 <strong>-d</strong> 指定容器的运行模式。</p><pre><code>$ docker run -itd --name ubuntu-test ubuntu /bin/bash</code></pre><p>点击图片查看大图：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/05/docker-run-d.png"><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/docker-stop-2.png" alt="img"></a></p><p><a href="https://www.runoob.com/wp-content/uploads/2016/05/docker-run-d2.png"><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/docker-stop-2.png" alt="img"></a></p><p><strong>注：</strong>加了 <strong>-d</strong> 参数默认不会进入容器，想要进入容器需要使用指令 <strong>docker exec</strong>（下面会介绍到）。</p><h3 id="4-停止一个容器"><a href="#4-停止一个容器" class="headerlink" title="4. 停止一个容器"></a>4. 停止一个容器</h3><p>停止容器的命令如下：</p><pre><code>$ docker stop &lt;容器 ID&gt;</code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/docker-stop-2.png" alt="img"></p><p>停止的容器可以通过 docker restart 重启：</p><pre><code>$ docker restart &lt;容器 ID&gt;</code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/docker-stop-2.png" alt="img"></p><h3 id="5-进入容器"><a href="#5-进入容器" class="headerlink" title="5. 进入容器"></a>5. 进入容器</h3><p>在使用 <strong>-d</strong> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p><ul><li><strong>docker attach</strong></li><li><strong>docker exec</strong>：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。</li></ul><p><strong>attach 命令</strong></p><p>下面演示了使用 docker attach 命令。</p><pre><code>$ docker attach 1e560fca3906 </code></pre><p><a href="https://www.runoob.com/wp-content/uploads/2016/05/docker-attach.png"><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/docker-attach_1.png" alt="img"></a></p><p><strong>注意：</strong> 如果从这个容器退出，会导致容器的停止。</p><p><strong>exec 命令</strong></p><p>下面演示了使用 docker exec 命令。</p><pre><code>docker exec -it 243c32535da7 /bin/bash</code></pre><p><a href="https://www.runoob.com/wp-content/uploads/2016/05/docker-exec.png"><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/docker-attach_1.png" alt="img"></a></p><p><strong>注意：</strong> 如果从这个容器退出，不会导致容器的停止，这就是为什么推荐大家使用 <strong>docker exec</strong> 的原因。</p><p>更多参数说明请使用 <strong>docker exec –help</strong> 命令查看。</p><h2 id="Docker-容器连接"><a href="#Docker-容器连接" class="headerlink" title="Docker 容器连接"></a>Docker 容器连接</h2><p>前面我们实现了通过网络端口来访问运行在 docker 容器内的服务。</p><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <strong>-P</strong> 或 <strong>-p</strong> 参数来指定端口映射。</p><p>下面我们来实现通过端口连接到一个 docker 容器。</p><hr><h3 id="网络端口映射"><a href="#网络端口映射" class="headerlink" title="网络端口映射"></a>网络端口映射</h3><p>我们创建了一个 python 应用的容器。</p><pre><code>runoob@runoob:~$ docker run -d -P training/webapp python app.pyfce072cc88cee71b1cdceb57c2821d054a4a59f67da6b416fceb5593f059fc6d</code></pre><p>另外，我们可以指定容器绑定的网络地址，比如绑定 127.0.0.1。</p><p>我们使用 <strong>-P</strong> 参数创建一个容器，使用 <strong>docker ps</strong> 可以看到容器端口 5000 绑定主机端口 32768。</p><pre><code>runoob@runoob:~$ docker psCONTAINER ID    IMAGE               COMMAND            ...           PORTS                     NAMESfce072cc88ce    training/webapp     &quot;python app.py&quot;    ...     0.0.0.0:32768-&gt;5000/tcp   grave_hopper</code></pre><p>我们也可以使用 <strong>-p</strong> 标识来指定容器端口绑定到主机端口。</p><p>两种方式的区别是:</p><ul><li><strong>-P :**是容器内部端口</strong>随机**映射到主机的高端口。</li><li><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口。</li></ul><pre><code>runoob@runoob:~$ docker run -d -p 5000:5000 training/webapp python app.py33e4523d30aaf0258915c368e66e03b49535de0ef20317d3f639d40222ba6bc0runoob@runoob:~$ docker psCONTAINER ID        IMAGE               COMMAND           ...           PORTS                     NAMES33e4523d30aa        training/webapp     &quot;python app.py&quot;   ...   0.0.0.0:5000-&gt;5000/tcp    berserk_bartikfce072cc88ce        training/webapp     &quot;python app.py&quot;   ...   0.0.0.0:32768-&gt;5000/tcp   grave_hopper</code></pre><p>另外，我们可以指定容器绑定的网络地址，比如绑定 127.0.0.1。</p><pre><code>runoob@runoob:~$ docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py95c6ceef88ca3e71eaf303c2833fd6701d8d1b2572b5613b5a932dfdfe8a857crunoob@runoob:~$ docker psCONTAINER ID        IMAGE               COMMAND           ...     PORTS                                NAMES95c6ceef88ca        training/webapp     &quot;python app.py&quot;   ...  5000/tcp, 127.0.0.1:5001-&gt;5000/tcp   adoring_stonebraker33e4523d30aa        training/webapp     &quot;python app.py&quot;   ...  0.0.0.0:5000-&gt;5000/tcp               berserk_bartikfce072cc88ce        training/webapp     &quot;python app.py&quot;   ...    0.0.0.0:32768-&gt;5000/tcp              grave_hopper</code></pre><p>这样我们就可以通过访问 127.0.0.1:5001 来访问容器的 5000 端口。</p><p>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 <strong>/udp</strong>。</p><pre><code>runoob@runoob:~$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py6779686f06f6204579c1d655dd8b2b31e8e809b245a97b2d3a8e35abe9dcd22arunoob@runoob:~$ docker psCONTAINER ID        IMAGE               COMMAND           ...   PORTS                                NAMES6779686f06f6        training/webapp     &quot;python app.py&quot;   ...   5000/tcp, 127.0.0.1:5000-&gt;5000/udp   drunk_visvesvaraya95c6ceef88ca        training/webapp     &quot;python app.py&quot;   ...    5000/tcp, 127.0.0.1:5001-&gt;5000/tcp   adoring_stonebraker33e4523d30aa        training/webapp     &quot;python app.py&quot;   ...     0.0.0.0:5000-&gt;5000/tcp               berserk_bartikfce072cc88ce        training/webapp     &quot;python app.py&quot;   ...    0.0.0.0:32768-&gt;5000/tcp              grave_hopper</code></pre><p><strong>docker port</strong> 命令可以让我们快捷地查看端口的绑定情况。</p><pre><code>runoob@runoob:~$ docker port adoring_stonebraker 5000127.0.0.1:5001</code></pre><hr><h3 id="Docker-容器互联"><a href="#Docker-容器互联" class="headerlink" title="Docker 容器互联"></a>Docker 容器互联</h3><p>端口映射并不是唯一把 docker 连接到另一个容器的方法。</p><p>docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。</p><p>docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</p><hr><h4 id="容器命名"><a href="#容器命名" class="headerlink" title="容器命名"></a>容器命名</h4><p>当我们创建一个容器的时候，docker 会自动对它进行命名。另外，我们也可以使用 <strong>–name</strong> 标识来命名容器，例如：</p><pre><code>runoob@runoob:~$  docker run -d -P --name runoob training/webapp python app.py43780a6eabaaf14e590b6e849235c75f3012995403f97749775e38436db9a441</code></pre><p>我们可以使用 <strong>docker ps</strong> 命令来查看容器名称。</p><pre><code>runoob@runoob:~$ docker ps -lCONTAINER ID     IMAGE            COMMAND           ...    PORTS                     NAMES43780a6eabaa     training/webapp   &quot;python app.py&quot;  ...     0.0.0.0:32769-&gt;5000/tcp   runoob</code></pre><h4 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h4><p>下面先创建一个新的 Docker 网络。</p><pre><code>$ docker network create -d bridge test-net</code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/docker-net6@.png" alt="img"></p><p>参数说明：</p><p><strong>-d</strong>：参数指定 Docker 网络类型，有 bridge、overlay。</p><p>其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。</p><h4 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h4><p>运行一个容器并连接到新建的 test-net 网络:</p><pre><code>$ docker run -itd --name test1 --network test-net ubuntu /bin/bash</code></pre><p>打开新的终端，再运行一个容器并加入到 test-net 网络:</p><pre><code>$ docker run -itd --name test2 --network test-net ubuntu /bin/bash</code></pre><p>点击图片查看大图：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/05/docker-net2.png"><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/docker-net6@.png" alt="img"></a></p><p>下面通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。</p><p>如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上俩个容器）。</p><pre><code>apt-get updateapt install iputils-ping</code></pre><p>在 test1 容器输入以下命令：</p><p>点击图片查看大图：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/05/docker-net3.png"><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/docker-net6@.png" alt="img"></a></p><p>同理在 test2 容器也会成功连接到:</p><p>点击图片查看大图：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/05/docker-net4.png"><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/docker-net6@.png" alt="img"></a></p><p>这样，test1 容器和 test2 容器建立了互联关系。</p><p>如果你有多个容器之间需要互相连接，推荐使用 Docker Compose，后面会介绍。</p><hr><h3 id="配置-DNS"><a href="#配置-DNS" class="headerlink" title="配置 DNS"></a>配置 DNS</h3><p>我们可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：</p><pre><code>&#123;  &quot;dns&quot; : [    &quot;114.114.114.114&quot;,    &quot;8.8.8.8&quot;  ]&#125;</code></pre><p>设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。</p><p>配置完，需要重启 docker 才能生效。</p><p>查看容器的 DNS 是否生效可以使用以下命令，它会输出容器的 DNS 信息：</p><pre><code>$ docker run -it --rm  ubuntu  cat etc/resolv.conf</code></pre><p>点击图片查看大图：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/05/docker-net5.png"><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/docker-net6@.png" alt="img"></a></p><p><strong>手动指定容器的配置</strong></p><p>如果只想在指定的容器设置 DNS，则可以使用以下命令：</p><pre><code>$ docker run -it --rm -h host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu</code></pre><p>参数说明：</p><p><strong>–rm</strong>：容器退出时自动清理容器内部的文件系统。</p><p><strong>-h HOSTNAME 或者 –hostname=HOSTNAME</strong>： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</p><p><strong>–dns=IP_ADDRESS</strong>： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</p><p><strong>–dns-search=DOMAIN</strong>： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。</p><p>点击图片查看大图：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/05/docker-net6.png"><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/docker-net6@.png" alt="img"></a></p><p>如果在容器启动时没有指定 <strong>–dns</strong> 和 <strong>–dns-search</strong>，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。</p><h1 id="Docker-cp-命令"><a href="#Docker-cp-命令" class="headerlink" title="Docker cp 命令"></a>Docker cp 命令</h1><p>**docker cp :**用于容器与主机之间的数据拷贝。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</code></pre><p>OPTIONS说明：</p><ul><li>**-L :**保持源目标中的链接</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</p><pre><code>docker cp /www/runoob 96f7f14e99ab:/www/</code></pre><p>将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</p><pre><code>docker cp /www/runoob 96f7f14e99ab:/www</code></pre><p>将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。</p><pre><code>docker cp  96f7f14e99ab:/www /tmp/</code></pre><h3 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h3><pre class=" language-shell"><code class="language-shell"># 匿名挂载-v 容器内的路径！docker run -d -P --name nginx01 -v /etc/nginx nginx# 具名挂载docker run -d -P --name nginx01 -v juming-nginx:/etc/nginx nginx# 指定路径挂载docker run -d -P --name nginx01 -v /home/juming-nginx:/etc/nginx nginx# ro/rw readonly readwrite# 一旦设置了容器的权限，容器对我们挂载出来的内容就有限定了！docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx# ro 只要看到ro,就说明这个路径只能通过宿主机来操作，容器内部是无法操作！！！docker volumne lsdocker volumne inspect juming-nginx# 查找具名挂载的数据卷的地址# 一般在/var/lib/docker/volumnes/xxx/_data</code></pre><h3 id="初始Dockerfile"><a href="#初始Dockerfile" class="headerlink" title="初始Dockerfile"></a>初始Dockerfile</h3><h4 id="什么是-Dockerfile？"><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h4><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><h4 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h4><p>这里仅讲解如何运行 Dockerfile 文件来定制一个镜像，具体 Dockerfile 文件内指令详解，将在下一节中介绍，这里你只要知道构建的流程即可。</p><p><strong>1、下面以定制一个 nginx 镜像（构建好的镜像内会有一个 /usr/share/nginx/html/index.html 文件）</strong></p><p>在一个空目录下，新建一个名为 Dockerfile 文件，并在文件内添加以下内容：</p><pre><code>FROM nginxRUN echo &#39;这是一个本地构建的nginx镜像&#39; &gt; /usr/share/nginx/html/index.html</code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/dockerfile12.png" alt="img"></p><p><strong>2、FROM 和 RUN 指令的作用</strong></p><p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p><p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下俩种格式：</p><p>shell 格式：</p><pre><code>RUN &lt;命令行命令&gt;# &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</code></pre><p>exec 格式：</p><pre><code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]# 例如：# RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</code></pre><p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</p><p>FROM centos<br>RUN <strong>yum install</strong> <strong>wget</strong><br>RUN <strong>wget</strong> -O redis.tar.gz “<a href="http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;">http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</a><br>RUN <strong>tar</strong> -xvf redis.tar.gz<br>以上执行会创建 3 层镜像。可简化为以下格式：<br>FROM centos<br>RUN <strong>yum install</strong> <strong>wget</strong> <br>  <strong>&amp;&amp;</strong> <strong>wget</strong> -O redis.tar.gz “<a href="http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;">http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</a> <br>  <strong>&amp;&amp;</strong> <strong>tar</strong> -xvf redis.tar.gz</p><p>如上，以 <strong>&amp;&amp;</strong> 符号连接命令，这样执行后，只会创建 1 层镜像。</p><h4 id="开始构建镜像"><a href="#开始构建镜像" class="headerlink" title="开始构建镜像"></a>开始构建镜像</h4><p>在 Dockerfile 文件的存放目录下，执行构建动作。</p><p>以下示例，通过目录下的 Dockerfile 构建一个 nginx:test（镜像名称:镜像标签）。</p><p><strong>注</strong>：最后的 <strong>.</strong> 代表本次执行的上下文路径，下一节会介绍。</p><p>$ docker build -t nginx:test .</p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/dockerfile12.png" alt="img"></p><p>以上显示，说明已经构建成功。</p><h4 id="上下文路径"><a href="#上下文路径" class="headerlink" title="上下文路径"></a>上下文路径</h4><p>上一节中，有提到指令最后一个 <strong>.</strong> 是上下文路径，那么什么是上下文路径呢？</p><p>$ docker build -t nginx:test .</p><p>上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p><p><strong>解析</strong>：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p><p>如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</p><p><strong>注意</strong>：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p><hr><h2 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h2><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p><p>格式：</p><pre><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]</code></pre><p>**[–chown=<user>:<group>]**：可选参数，用户改变复制到容器内文件的拥有者和属组。</p><p>**&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p><pre><code>COPY hom* /mydir/COPY hom?.txt /mydir/</code></pre><p>**&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p><ul><li>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li><li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p><ul><li>CMD 在docker run 时运行。</li><li>RUN 是在 docker build。</li></ul><p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p><p>格式：</p><pre><code>CMD &lt;shell 命令&gt; CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</code></pre><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p><p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><p>格式：</p><pre><code>ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</code></pre><p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</p><p>示例：</p><p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><pre><code>FROM nginxENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 </code></pre><p>1、不传参运行</p><pre><code>$ docker run  nginx:test</code></pre><p>容器内会默认运行以下命令，启动主进程。</p><pre><code>nginx -c /etc/nginx/nginx.conf</code></pre><p>2、传参运行</p><pre><code>$ docker run  nginx:test -c /etc/nginx/new.conf</code></pre><p>容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p><pre><code>nginx -c /etc/nginx/new.conf</code></pre><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p><p>格式：</p><pre><code>ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></pre><p>以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p><pre><code>ENV NODE_VERSION 7.2.0RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \  &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;</code></pre><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p><p>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p><p>格式：</p><pre><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></pre><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p><p>作用：</p><ul><li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li><li>避免容器不断变大。</li></ul><p>格式：</p><pre><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]VOLUME &lt;路径&gt;</code></pre><p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>仅仅只是声明端口。</p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><pre><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></pre><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p><p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><p>格式：</p><pre><code>WORKDIR &lt;工作目录路径&gt;</code></pre><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p><p>格式：</p><pre><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></pre><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p><p>格式：</p><pre><code>HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令HEALTHCHECK [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。</code></pre><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p><p>格式：</p><pre><code>ONBUILD &lt;其它指令&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Information Security</title>
      <link href="/post/836d.html"/>
      <url>/post/836d.html</url>
      
        <content type="html"><![CDATA[<h3 id="信息安全导论"><a href="#信息安全导论" class="headerlink" title="信息安全导论"></a>信息安全导论</h3><h4 id="1-TCP-IP"><a href="#1-TCP-IP" class="headerlink" title="1. TCP/IP"></a>1. TCP/IP</h4><ul><li>TCP/UDP：TLS/SSL</li><li>IP：IPSEC</li></ul><h4 id="2-网络安全模型"><a href="#2-网络安全模型" class="headerlink" title="2. 网络安全模型"></a>2. 网络安全模型</h4><ul><li>要素<ul><li><font color=red>安全变换</font>（加密等）Q : 如何进行加密，加密的方法</li><li><font color=red>共享秘密</font>（密钥等）Q : 密钥的传输和共享</li></ul></li></ul><h4 id="3-对称密码技术和非对称密码技术"><a href="#3-对称密码技术和非对称密码技术" class="headerlink" title="3. 对称密码技术和非对称密码技术"></a>3. 对称密码技术和非对称密码技术</h4><ul><li>对称密码技术中，加密密钥和解密密钥相同，或者一个密钥可以从另一个导出，又称私钥密码体制<ul><li>分组密码</li><li>流密码</li><li>S={M，C，K，E，D}</li><li>C=E<del>k</del>(M) 加密</li><li>M=D<del>k</del>(C) 解密</li></ul></li><li>非对称密码体制：1970以后发明，公钥密码体制。加密用公钥，解密用私钥。</li></ul><h4 id="4-密码学的基本概念"><a href="#4-密码学的基本概念" class="headerlink" title="4. 密码学的基本概念"></a>4. 密码学的基本概念</h4><ul><li>密码编码学：对信息进行编码以达到信息的保密性</li><li>密码分析学：对密码数据进行分析和破译</li><li>Cryptology=Cryptography+Cryptoanalysis</li></ul><h4 id="5-密码体制"><a href="#5-密码体制" class="headerlink" title="5.  密码体制"></a>5.  密码体制</h4><ul><li>明文：M</li><li>密文：C</li><li>加密算法：E</li><li>解密算法：D</li><li>密钥：K</li><li>明文通过加密密钥进行加密变成密文</li><li>密文通过解密密钥进行解密变成明文</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mining Text Data</title>
      <link href="/post/a2fb.html"/>
      <url>/post/a2fb.html</url>
      
        <content type="html"><![CDATA[<h3 id="文本挖掘"><a href="#文本挖掘" class="headerlink" title="文本挖掘"></a><center>文本挖掘</center></h3><h4 id="1-教学信息"><a href="#1-教学信息" class="headerlink" title="1. 教学信息"></a>1. 教学信息</h4><ul><li><strong>崔万云</strong><ul><li><a href="mailto:&#x63;&#117;&#105;&#x2e;&#119;&#x61;&#110;&#x79;&#x75;&#x6e;&#x40;&#115;&#x75;&#102;&#x65;&#x2e;&#101;&#100;&#x75;&#46;&#x63;&#x6e;">&#x63;&#117;&#105;&#x2e;&#119;&#x61;&#110;&#x79;&#x75;&#x6e;&#x40;&#115;&#x75;&#102;&#x65;&#x2e;&#101;&#100;&#x75;&#46;&#x63;&#x6e;</a></li><li>答疑时间：周五：13:30-15:00,请事先邮件预约</li><li>办公室：信息管理学院306室</li></ul></li><li><strong>助教：闫森</strong><ul><li><a href="mailto:&#x4b;&#x69;&#x69;&#x69;&#x69;&#x69;&#105;&#x31;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#109;">&#x4b;&#x69;&#x69;&#x69;&#x69;&#x69;&#105;&#x31;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#109;</a></li><li>请将课程作业等发至助教邮箱</li></ul></li></ul><p><strong>运用Kaggle网站</strong></p><h4 id="2-参考书目"><a href="#2-参考书目" class="headerlink" title="2. 参考书目"></a>2. 参考书目</h4><ul><li>自然语言处理<ul><li>Speech and Language Processing, Daniel Jurafsky</li><li>Oxford Deep NLP 2017 course: <a href="https://github.com/oxford-cs-deepnlp-2017/lectures">https://github.com/oxford-cs-deepnlp-2017/lectures</a></li></ul></li><li>深度学习<ul><li>Deep Learning, lan Goodfellow and Yoshua Bengio and Aaron Courville,</li><li><a href="https://www.deeplearningbook.org/">https://www.deeplearningbook.org/</a></li></ul></li><li>Pytorch<ul><li>官方教程</li><li>中文文档</li></ul></li><li>神经科学、哲学类<ul><li>Learning how to learn <a href="https://www.coursera.org/learn/ruhe-xuexi/home/welcome">https://www.coursera.org/learn/ruhe-xuexi/home/welcome</a></li><li>The book of why: the new science of cause and effect, Pearl</li><li>思考，快与慢 丹尼尔·卡尼曼</li></ul></li></ul><h4 id="3-Information-Extraction-lt-信息抽取-gt"><a href="#3-Information-Extraction-lt-信息抽取-gt" class="headerlink" title="3. Information Extraction&lt;信息抽取&gt;"></a>3. Information Extraction&lt;信息抽取&gt;</h4><p>Hi Dan,we’ve now scheduled the curriculum meeting. It will be in Gates 159 tomorrow from 10:00-11:30.  Chris</p><ul><li>Event </li><li>Time</li><li>Place</li></ul><h4 id="4-Information-Extraction-amp-amp-Sentiment-Analysis"><a href="#4-Information-Extraction-amp-amp-Sentiment-Analysis" class="headerlink" title="4. Information Extraction &amp;&amp; Sentiment Analysis"></a>4. Information Extraction &amp;&amp; Sentiment Analysis</h4><blockquote><p>先通过<strong>知识抽取</strong>，把一条淘宝的评论中的信息抽取出来，作为tag，比如服务、物流……再通过<strong>情感分析</strong>判断这句话是评价<strong>good or bad</strong>。</p></blockquote><h4 id="5-Google翻译"><a href="#5-Google翻译" class="headerlink" title="5. Google翻译"></a>5. Google翻译</h4><h4 id="6-Language-Technology"><a href="#6-Language-Technology" class="headerlink" title="6. Language Technology"></a>6. Language Technology</h4><ul><li><p>mostly solved （目前钓鱼邮件分辨很难处理）</p><ul><li>Spam detection 垃圾邮件监测</li><li>Part-of-speech(POS) tagging 词性分析</li><li>Named entity recognition (NER) 寻找出主谓宾</li></ul></li><li><p>making good progress</p><ul><li>Sentiment analysis 情感分析</li></ul></li><li><p>Word sense disambiguation</p><ul><li>Parsing</li></ul></li><li><p>Machine translation(MT)</p><ul><li>Information extraction(IE)</li><li>Question answering (Q &amp; A) 单轮</li></ul></li><li><p>still really hard</p><ul><li>Paraphrase 判断两句话是否是一个意思</li><li>Summarization</li><li>Dialog 多轮对话</li><li>Coreference resolution 代词指代谁<ul><li>Jim comforts Kevin because he is sympathetic/crying</li></ul></li></ul></li></ul><h4 id="7-Why-else-is-natural-language-understanding-difficult"><a href="#7-Why-else-is-natural-language-understanding-difficult" class="headerlink" title="7. Why else is natural language understanding difficult?"></a>7. Why else is natural language understanding difficult?</h4><ul><li>non-standard English</li><li>segmentation issues</li><li>idioms</li><li>neologisms</li><li>world knowledge (self-supervised learning)</li><li>tricky entity names</li></ul><h4 id="8-Sentence-representation"><a href="#8-Sentence-representation" class="headerlink" title="8. Sentence representation"></a>8. Sentence representation</h4><ul><li>Bag-of-words 词袋模型 {Jim,comforts,Kevin,……}={comforts,Kevin,Jim,……}无序</li><li>N-gram model <ul><li>2-gram: Jim-comforts,comforts-Kevin,Kevin because</li><li>3-gram: Jim comforts Kevin,comforts-Kevin-because</li></ul></li><li>Embedding 基于神经网络表示</li></ul><h4 id="9-质疑与进展"><a href="#9-质疑与进展" class="headerlink" title="9. 质疑与进展"></a>9. 质疑与进展</h4><ul><li><p>SQuAD1.1 Leaderboard</p><p>Optimization： neural network + attention + self-supervision</p><p>神经网络 + 注意力机制（Bengio） + 自监督学习（Google）</p></li><li><p>2020年NLP技术的国内外前沿对比</p></li></ul><h4 id="10-Skills-you’ll-need"><a href="#10-Skills-you’ll-need" class="headerlink" title="10. Skills you’ll need"></a>10. Skills you’ll need</h4><ul><li>Simple linear algerbra(vectors,matrices)</li><li>Basic probability theory</li><li>Python programming</li><li>Neural networks</li><li>AND Pytorch!</li></ul><h4 id="11-Outline"><a href="#11-Outline" class="headerlink" title="11. Outline"></a>11. Outline</h4><ul><li><p>Paty I -Neural Networks are our friends</p></li><li><p>Model = function + params</p><p><strong>y=wx+b</strong></p><p>w,b : <strong>params</strong></p><p>y     : <strong>output</strong></p><p>x     : <strong>input</strong></p><p><strong>Input - Fixed, comes from data</strong></p><p><strong>Parameters - Need to be estimated</strong></p><p>yhat: <strong>true data</strong></p></li></ul><h4 id="12-Loss-Cost-Function-are-our-friends"><a href="#12-Loss-Cost-Function-are-our-friends" class="headerlink" title="12. Loss/Cost Function are our friends"></a>12. Loss/Cost Function are our friends</h4><p>L(model) -&gt;R    模型对训练数据的损失</p><blockquote><p>等价于参数对训练数据的损失——因为参数是未知的，model=function+params</p></blockquote><p>L(params)-&gt;R  </p><p>输入一个model 得出一个损失，输入一组params输出一个损失。</p><h4 id="13-小样本学习"><a href="#13-小样本学习" class="headerlink" title="13. 小样本学习"></a>13. 小样本学习</h4><p>通常的机器学习任务：给定模型（人定），计算机求解模型</p><p>模型搜索任务：计算机求解合适的模型，及该模型的参数</p><p>neural architecture search</p><h3 id="Into-Deep-Learning"><a href="#Into-Deep-Learning" class="headerlink" title="Into Deep Learning"></a>Into Deep Learning</h3><h4 id="Nonlinear-Neural-Models"><a href="#Nonlinear-Neural-Models" class="headerlink" title="Nonlinear Neural Models"></a>Nonlinear Neural Models</h4>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos 7-nginx的安装</title>
      <link href="/post/5eca.html"/>
      <url>/post/5eca.html</url>
      
        <content type="html"><![CDATA[<h1 id="centOS7安装Nginx及简单配置"><a href="#centOS7安装Nginx及简单配置" class="headerlink" title="centOS7安装Nginx及简单配置"></a>centOS7安装Nginx及简单配置</h1><p>Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p><h2 id="1-安装Nginx前的准备"><a href="#1-安装Nginx前的准备" class="headerlink" title="1.安装Nginx前的准备"></a>1.安装Nginx前的准备</h2><p>由于nginx的一些模块依赖一些lib库，所以在安装nginx之前，必须先安装这些lib库，主要有g++、gcc、openssl-devel、pcre-devel和zlib-devel 。</p><blockquote><p>注意原博主下面的命令有误</p></blockquote><p>所以执行如下命令安装</p><pre><code>yum install gcc-g++yum install pcre pcre-develyum install zlib zlib-develyum install openssl openssl-devel</code></pre><h2 id="2-安装Nginx"><a href="#2-安装Nginx" class="headerlink" title="2.安装Nginx"></a>2.安装Nginx</h2><h5 id="1-从官网下载最新稳定版的nginx"><a href="#1-从官网下载最新稳定版的nginx" class="headerlink" title="(1) 从官网下载最新稳定版的nginx"></a>(1) 从官网下载最新稳定版的nginx</h5><p>官网地址：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/20191015092125278.png"></p><p>输入：</p><p><code>wget http://nginx.org/download/nginx-1.16.1.tar.gz</code></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/20191015092143520.png" alt="在这里插入图片描述"></p><h5 id="2-解压"><a href="#2-解压" class="headerlink" title="(2) 解压"></a>(2) 解压</h5><p>输入：</p><p><code>tar -zxvf nginx-1.16.1.tar.gz</code><br><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/20191015092155895.png"></p><h5 id="3-使用默认配置"><a href="#3-使用默认配置" class="headerlink" title="(3) 使用默认配置"></a>(3) 使用默认配置</h5><pre><code>cd nginx-1.16.1./configure --prefix=/usr/local/nginx --with-http_ssl_module</code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/20191015092209745.png"></p><h5 id="4-编译安装"><a href="#4-编译安装" class="headerlink" title="(4) 编译安装"></a>(4) 编译安装</h5><p><code>make &amp;&amp; make install</code></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/20191015092222258.png"></p><h5 id="5-查看nginx的位置"><a href="#5-查看nginx的位置" class="headerlink" title="(5) 查看nginx的位置"></a>(5) 查看nginx的位置</h5><p>输入：</p><pre><code>whereis nginx</code></pre><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/2019101509224531.png"></p><h2 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3. 常用命令"></a>3. 常用命令</h2><h5 id="1-修改配置："><a href="#1-修改配置：" class="headerlink" title="1. 修改配置："></a>1. 修改配置：</h5><pre><code>vi /usr/local/nginx/conf/nginx.conf</code></pre><h5 id="2-启动nginx-如果运行reload是报错缺少error就执行此步"><a href="#2-启动nginx-如果运行reload是报错缺少error就执行此步" class="headerlink" title="2. 启动nginx(如果运行reload是报错缺少error就执行此步)"></a>2. 启动nginx(如果运行reload是报错缺少error就执行此步)</h5><pre><code>sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code></pre><h5 id="3-汇总"><a href="#3-汇总" class="headerlink" title="3. 汇总"></a>3. 汇总</h5><ul><li>启动：<code>/usr/local/nginx/sbin/nginx</code></li><li>关闭：<code>/usr/local/nginx/sbin/nginx -s stop</code></li><li>重启：<code>/usr/local/nginx/sbin/nginx -s reload</code></li><li>查看nginx的进程pid： <code>cat /usr/local/nginx/logs/nginx.pid</code></li><li>查看版本：<code>/usr/local/nginx/sbin/nginx -V</code></li><li>修改配置文件：<code>vim /usr/local/nginx/conf/nginx.conf</code></li><li>修改完后测试：<code>/usr/local/nginx/sbin/nginx -t</code></li></ul><p>tips：为 nginx 取别名，后面可直接用🧡</p><pre><code>alias nginx=&#39;/usr/local/nginx/sbin/nginx&#39;</code></pre><ul><li><p>启动：<code>nginx</code></p></li><li><p>关闭：<code>nginx -s stop</code></p></li><li><p>平稳关闭: <code>nginx -s quit #平稳关闭nginx，保存相关信息，有安排的结束web服务</code></p></li><li><p>重启：<code>nginx -s reload</code></p></li><li><p>查看nginx的进程pid： <code>cat /usr/local/nginx/logs/nginx.pid</code></p></li><li><p>查看版本：<code>nginx -V</code></p></li><li><p>修改配置文件：<code>vim /usr/local/nginx/conf/nginx.conf</code></p></li><li><p>修改完后测试：<code>nginx -t</code></p></li><li><p>查询nginx进程</p><pre><code>ps aux|grep nginx</code></pre></li></ul><p>转载自：<a href="https://blog.csdn.net/weixin_42014622/article/details/102560705">https://blog.csdn.net/weixin_42014622/article/details/102560705</a></p><p>安全狗下载：<a href="https://blog.csdn.net/jmkweb/article/details/91912414">https://blog.csdn.net/jmkweb/article/details/91912414</a></p><p><a href="https://blog.csdn.net/cungudafa/article/details/106871392">https://blog.csdn.net/cungudafa/article/details/106871392</a></p><pre><code>cd rootwget http://down.safedog.cn/safedog_linux64.tar.gztar xzvf safedog_linux64.tar.gzcd safedog_an_linux64_2.8.21207/chmod +x install.pyyum -y install mlocate  #locate缺失yum -y install pciutils #Ispciyum -y install lsof     #lsof#停止nginxnginx -s stop./install.py#什么都不选1,2完成后配置服云即可</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo配置到阿里云</title>
      <link href="/post/6cb8.html"/>
      <url>/post/6cb8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo配置到阿里云上"><a href="#Hexo配置到阿里云上" class="headerlink" title="Hexo配置到阿里云上"></a>Hexo配置到阿里云上</h1><blockquote><p>相关博客的借鉴<br><a href="https://blog.csdn.net/NoCortY/article/details/99631249">https://blog.csdn.net/NoCortY/article/details/99631249</a><br><a href="https://blog.csdn.net/cungudafa/article/details/104585711">https://blog.csdn.net/cungudafa/article/details/104585711</a></p></blockquote><h2 id="一、安装ngnix"><a href="#一、安装ngnix" class="headerlink" title="一、安装ngnix"></a>一、安装ngnix</h2><ol><li>我们需要nginx作为我们的服务器，所以我们首先要安装nginx。可以使用yum命令直接进行安装，安装执行命令如下<br><code>yum install -y nginx</code></li><li>启动服务器：<pre><code>systemctl start nginxsystemctl enable nginx</code></pre>如果第一个命令错误，关闭apache的80端口<pre><code>vim /etc/httpd/conf/httpd.confsystemctl restart httpd.service</code></pre>apache443端口修改<br><a href="https://blog.csdn.net/wudinaniya/article/details/87873469">https://blog.csdn.net/wudinaniya/article/details/87873469</a></li><li>我们要记住的是**/etc/nginx/**是nginx默认的配置路径，一会要用到。</li></ol><h2 id="二、安装Node-js"><a href="#二、安装Node-js" class="headerlink" title="二、安装Node.js"></a>二、安装Node.js</h2><ol><li>安装nodejs有很多种方式，我这边就说一种<pre><code>curl -sL https://rpm.nodesource.com/setup_10.x | bash -yum install -y nodejs</code></pre></li><li>安装完成后执行 <code>node -v</code>和 <code>npm -v</code>如果打印版本号则安装成功</li></ol><h2 id="三、安装Git及配置仓库"><a href="#三、安装Git及配置仓库" class="headerlink" title="三、安装Git及配置仓库"></a>三、安装Git及配置仓库</h2><p><code>yum install git</code><br>见<a href="https://blog.csdn.net/NoCortY/article/details/99631249">https://blog.csdn.net/NoCortY/article/details/99631249</a></p><h2 id="四、创建blog-git空仓库"><a href="#四、创建blog-git空仓库" class="headerlink" title="四、创建blog.git空仓库"></a>四、创建blog.git空仓库</h2><p><a href="https://blog.csdn.net/cungudafa/article/details/104585711">https://blog.csdn.net/cungudafa/article/details/104585711</a></p><p>五、nginx配置<br><code>vi /etc/nginx/nginx.conf</code></p><ul><li>端口号（阿里云控制台安全组规则要打开端口哦）</li><li>修改域名</li><li>修改根目录位置  <pre><code>location/&#123;  root /home/git/projects/blog;&#125;</code></pre></li><li>修改用户为root用户 将user ngnix改为user root</li></ul><p>在服务器上重新运行nginx服务器<br><code>nginx -s reload</code></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Aliyun </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用阿里云部署Flask网页</title>
      <link href="/post/6dff.html"/>
      <url>/post/6dff.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用阿里云部署Flask网页"><a href="#使用阿里云部署Flask网页" class="headerlink" title="使用阿里云部署Flask网页"></a>使用阿里云部署Flask网页</h1><h2 id="前端网页部署"><a href="#前端网页部署" class="headerlink" title="前端网页部署"></a>前端网页部署</h2><p><a href="https://www.jianshu.com/p/91308bd1414e">阿里云apache-CentOS</a><br>配置好Apache后，将一整个html、css、js文件全部copy进/var/www/html目录下。</p><p>之后就可以通过访问IP地址访问到你的index.html网页。</p><p><code>sudo yum update</code></p><h2 id="后端Flask部署"><a href="#后端Flask部署" class="headerlink" title="后端Flask部署"></a>后端Flask部署</h2><p><code>python3 -m pip install --upgrade pip --force-reinstall</code></p><p><code>pip3 install --upgrade pip</code></p><p><code>pip install flask</code></p><p>单独安装torch以及torchvision，否则会直接安装GPU版本<br><a href="https://download.pytorch.org/whl/torch_stable.html">https://download.pytorch.org/whl/torch_stable.html</a><br>选择合适的版本。</p><p>建议在本地下载完成之后上传</p><pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> https://download.pytorch.org/whl/cpu/torchvision-0.5.0%2Bcpu-cp36-cp36m-linux_x86_64.whl<span class="token function">wget</span> https://download.pytorch.org/whl/cpu/torch-1.4.0%2Bcpu-cp36-cp36m-linux_x86_64.whlpip3 <span class="token function">install</span> torchvision-0.5.0%2Bcpu-cp36-cp36m-linux_x86_64.whlpip3 <span class="token function">install</span> torch-1.4.0%2Bcpu-cp36-cp36m-linux_x86_64.whl</code></pre><p>进入到后端服务的文件夹，将其余的环境依赖安装好。</p><pre class=" language-bash"><code class="language-bash"> pip <span class="token function">install</span> -r requirements.txt</code></pre><p>运行server.py文件即可。</p><pre class=" language-bash"><code class="language-bash">python3 server.py</code></pre><p>&lt;如果遇到没有找到cv2包，重新<code>pip3 uninstall opencv-python pip3 install opencv-python</code>&gt;或者尝试yum install opencv-python</p><p>最后记得reboot</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aliyun </tag>
            
            <tag> Flask </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Royal TSX通过阿里云搭建属于自己的linux主机（配合Python和Anaconda的安装）</title>
      <link href="/post/11db.html"/>
      <url>/post/11db.html</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎来到shenhao的AI-大数据技术之旅blog-Royal-TSX的配置"><a href="#欢迎来到shenhao的AI-大数据技术之旅blog-Royal-TSX的配置" class="headerlink" title="欢迎来到shenhao的AI +大数据技术之旅blog-Royal TSX的配置"></a>欢迎来到shenhao的AI +大数据技术之旅blog-Royal TSX的配置</h1><p>在这一篇文章中，我讲从安装到配置使用<strong>SSH以及STFP</strong>进行详细的说明。同时，会对<strong>Linux系统</strong>上安装python以及anaconda的详细步骤进行阐述。最终将配置一个<strong>pytorch环境</strong>作为最终的案例。<br>[video(video-5dCgroSF-1596276347458)(type-bilibili)(url-<a href="https://player.bilibili.com/player.html?aid=70623689)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/4755957f5d4ab25eea49d6458701ccf7e93f5cbe.jpg)">https://player.bilibili.com/player.html?aid=70623689)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/4755957f5d4ab25eea49d6458701ccf7e93f5cbe.jpg)</a>(title-怎样在Mac上SSH和FTP？完美替代XShell是哪个软件？item2吗？Royal TSX! 没有比它更好)]</p><h2 id="安装Royal-TSX"><a href="#安装Royal-TSX" class="headerlink" title="安装Royal TSX"></a>安装Royal TSX</h2><p>在 Windows 上好用的 shell 工具可能要数 <strong>xshell</strong>，但xshell并没有开发 mac 版本，所以想和远程服务器SSH连接可能要用macOS自带的终端 terminal 或者 iTerm2。<br>试过几个工具软件后，在macOS上最好用ssh工具客户端可能是 Royal TSX。（<strong>国产的Finalshell</strong>也能从一定程度上替代xshell，但是Royal TSX集成了更多的功能，也更为丰富）</p><ol><li><p>安装地址：<a href="https://royalapps.com/ts/mac/download">https://royalapps.com/ts/mac/download</a></p></li><li><p>下载完成后呈现如下的图片<br><img src="https://img-blog.csdnimg.cn/20200801015204281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="这是官方的图片"></p><h2 id="阿里云申请云服务器ECS"><a href="#阿里云申请云服务器ECS" class="headerlink" title="阿里云申请云服务器ECS"></a>阿里云申请云服务器ECS</h2></li><li><p>登陆阿里云平台申请或购买云服务器（点击概览会详细的官方教程）<br><img src="https://img-blog.csdnimg.cn/20200801020643706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此时注意，我们只需要IP地址栏的公有IP地址。</p></li><li><p>找到目标实例，然后在操作列选择 【更多】 &gt;【 密码/密钥 】&gt; 重置实例密码，然后在弹出的对话框设置ECS实例的登录密码。<br><img src="https://img-blog.csdnimg.cn/20200801021014389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>在弹出的页面，单击【立即重启】使新密码生效。</p></li><li><p>在ECS实例列表页面，复制ECS实例的公网IP地址。</p><h2 id="安装连接SSH"><a href="#安装连接SSH" class="headerlink" title="安装连接SSH"></a>安装连接SSH</h2></li><li><p>安装Terminal插件。Royal TSX是一个插件型连接app，所有功能依靠插件实现。<br><img src="https://img-blog.csdnimg.cn/20200801015347684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>点击File-New Document，创建一个Document。试用版只能开一个Document，使用上没有任何限制。Document可以理解成一套链接配置文件。<br>然后点击新建的Document。点击左下角的+号-Terminal<br><img src="https://img-blog.csdnimg.cn/2020080101560987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>注意Computer Name就是供应商给出的ip地址。Port什么的默认不变。点击apply按钮。Display Name改为你自己取的名字。<br><img src="https://img-blog.csdnimg.cn/20200801015611412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>选择Common一栏中的Credentials，点击第一次选取框，选择Specify username and password。输入Username以及Password。之后Commond S保存后双击执行即可。<br><img src="https://img-blog.csdnimg.cn/20200801015837788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>输入 yes，然后输入云服务器的登录密码。<img src="https://img-blog.csdnimg.cn/20200801021253877.png" alt="在这里插入图片描述"><br>登录成功后会显示如下信息。<br><img src="https://img-blog.csdnimg.cn/20200801021253951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>之后我们就可以快乐的使用SSH啦！！！</p></li></ol><h2 id="配置使用SFTP"><a href="#配置使用SFTP" class="headerlink" title="配置使用SFTP"></a>配置使用SFTP</h2><ol><li>安装File Transfer插件</li><li>在Document下新建File Transfer项目。步骤和SSH类似，输入Computer Name（公共IP）。在这里我们选择SFTP type。<br><img src="https://img-blog.csdnimg.cn/20200801021455994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>进入Credentials，输入用户名和密码。双击即可登陆，如果熟悉Xshell的小伙伴就会很熟悉这个界面了。<br><img src="https://img-blog.csdnimg.cn/20200801021737716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><h2 id="在Linux系统中配置Python3环境"><a href="#在Linux系统中配置Python3环境" class="headerlink" title="在Linux系统中配置Python3环境"></a>在Linux系统中配置Python3环境</h2></li><li>默认情况下，Linux会自带安装Python，可以运行python –version命令查看，如图：<br><img src="https://img-blog.csdnimg.cn/20200801022155121.png#pic_center" alt="在这里插入图片描述"><br>我们看到Linux中已经自带了Python2.7.5。再次运行python命令后就可以使用python命令窗口了。</li><li>安装python3</li></ol><ul><li>登录<a href="https://www.python.org/downloads/source/">https://www.python.org/downloads/source/</a>，找到对应版本（我们以Python 3.8.5为例）</li><li>选择Gzipped source tarball进行下载。</li><li>下载Python-3.8.5.tgz</li><li>文件上传：<br>将文件上传到Linux系统的某个目录下，根据自己情况上传，本例上传到了/root/目录下，如图：<br><img src="https://img-blog.csdnimg.cn/20200801022647884.png#pic_center" alt="在这里插入图片描述"></li><li>解压</li></ul><p>执行<code>tar -zxvf Python-3.6.5.tgz</code>命令，将文件解压到当前目录。</p><ul><li>准备编译环境，执行如下命令：<pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc <span class="token function">make</span></code></pre>安装python需要的依赖。成功后（Complete!）。</li><li>编译安装，执行<code>cd Python-3.8.5</code>进入解压后的Python-3.8.5目录下，依次执行如下三个命令：</li></ul><pre class=" language-bash"><code class="language-bash">./configure --prefix<span class="token operator">=</span>/root/training/Python-3.8.5<span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span></code></pre><ul><li>创建软链接<br>还记得开始，Linux已经安装了python2.7.5，这里我们不能将它删除，如果删除，系统可能会出现问题。我们只需要按照与Python2.7.5相同的方式为Python3.8.5创建一个软链接即可，我们把软链接放到/usr/local/bin目录下。<br>执行如下代码：</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">ln</span> -s root/training/Python-3.8.5/bin/python3.8 /usr/local/bin/python3<span class="token function">ls</span> -l /usr/local/bin/</code></pre><p>此时运行python3即可。<br><img src="https://img-blog.csdnimg.cn/20200801023426187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>配置环境变量</li></ul><p>配置环境变量主要是能快速使用pip3安装命令。</p><p>执行 <code>vi ~/.bash_profile</code>，打开配置文件，添加如下配置：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#配置python</span><span class="token function">export</span> PYTHON_HOME<span class="token operator">=</span>/root/training/Python-3.8.5<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PYTHON_HOME</span>/bin:<span class="token variable">$PATH</span></code></pre><p>保存退出（:wq），执行<code>source ~/.bash_profile</code>命令使配置生效。执行echo命令<code>echo $PYTHON_HOME/</code>，查看是否配置成功，如图：<br><img src="https://img-blog.csdnimg.cn/2020080102373583.png#pic_center" alt="在这里插入图片描述"></p><h2 id="Anaconda配置"><a href="#Anaconda配置" class="headerlink" title="Anaconda配置"></a>Anaconda配置</h2><ol><li>地址：<a href="https://www.anaconda.com/download/">https://www.anaconda.com/download/</a><br>打开如下图所示，这里大家就可以选择版本和适用的操作系统（Windows系统，苹果系统，Linux系统），这里我们下载Linux系统，另外python版本最好选择python3（就是图中的python3.8，因为官方已经不支持python2的维护了，并且python3不向下兼容，所以使用python3是大势所趋），并且更具自己的系统选择64位还是32位。<br><img src="https://img-blog.csdnimg.cn/20200801024035398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>下好安装包（这里指的是Linux下的安装包），我们将安装包拷贝到Linux系统下。（通过SFPT接口安装到/home/shenhao目录下）可以先用mkdir创建/shenhao</li><li>安装anaconda</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">bash</span> Anaconda3-2020.07-Linux-x86_64.sh</code></pre><p>然后一步步安装就可以了</p><blockquote><p>注意:安装的过程中要选择“yes”/“no”,一律选择“yes”，另外，会有一段安装的条款，我们一直回车就可以跳过。</p></blockquote><p><strong>安装完成之后要重启终端</strong>，anaconda才能生效</p><blockquote><ul><li>在安装的过程中，会问你安装路径，直接回车默认就可以了。有个地方问你是否将anaconda安装路径加入到环境变量（.bashrc)中，输入yes，默认的是no，</li><li>如果没输入就要配置环境，根据提示，在终端输入sudo vi /etc/profile，打开profile文件。添加语句export PATH=/home/shenhao/anaconda3/bin:$PATH，保存，退出。</li><li>重启终端</li></ul></blockquote><ul><li>输入conda list 就可以查询，你现在安装了哪些库，常用的numpy, scipy名列其中。如果你还有什么包没有安装上，可以运行conda install * 来进行安装，</li><li>如果某个包版本不是最新的，运行 conda update * 就可以了。</li></ul><h2 id="配置pytorch"><a href="#配置pytorch" class="headerlink" title="配置pytorch"></a>配置pytorch</h2><ol><li>配置清华源：<br>由于很多的python下的工具包的安装包在国外的服务器上，会影响国内的下载与使用，所以我们可以添加一下清华镜像，输入下面3句话就可以了。</li></ol><pre class=" language-bash"><code class="language-bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls <span class="token function">yes</span></code></pre><ol start="2"><li>pytorch环境：</li></ol><pre class=" language-bash"><code class="language-bash">conda create --name pytorch python<span class="token operator">=</span>3.8conda activate pytorchconda <span class="token function">install</span> pytorch torchvisionconda <span class="token function">install</span> scikit-learn</code></pre><p>如果要删除环境</p><pre class=" language-bash"><code class="language-bash">conda remove -n pytorch --all</code></pre><blockquote><p><a href="https://blog.csdn.net/weixin_41481113/article/details/83387315">linux下安装anaconda教程，并添加清华镜像</a><br><a href="https://www.bilibili.com/video/BV1EE411f7kZ?t=500">怎样在Mac上SSH和FTP？完美替代XShell是哪个软件？item2吗？Royal TSX! 没有比它更好</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aliyun </tag>
            
            <tag> Royal TSX </tag>
            
            <tag> VNC </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VNC远程图形桌面的配置之Ubuntu 18.04的Gnome实现</title>
      <link href="/post/a94f.html"/>
      <url>/post/a94f.html</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎来到shenhao的AI-大数据技术之旅blog-VNC远程图形桌面的配置之Ubuntu-18-04的Gnome实现"><a href="#欢迎来到shenhao的AI-大数据技术之旅blog-VNC远程图形桌面的配置之Ubuntu-18-04的Gnome实现" class="headerlink" title="欢迎来到shenhao的AI +大数据技术之旅blog-VNC远程图形桌面的配置之Ubuntu 18.04的Gnome实现"></a>欢迎来到shenhao的AI +大数据技术之旅blog-VNC远程图形桌面的配置之Ubuntu 18.04的Gnome实现</h1><p>VNC代表虚拟网络计算。从本质上讲，它是一个远程显示系统，不仅允许您在当前运行的计算机上查看桌面环境，而且从Internet上的任何地方的不同体系结构的计算机中查看远端的“桌面”环境。</p><p>VNC Server是用于在Linux环境中执行VNC（虚拟网络计算）桌面的软件。不同于Windows操作系统，只需激活远程桌面；在Linux上，必须安装VNC Server才能实时远程桌面。VNC服务器有很多软件，这里讨论如何使用TigerVNC安装VNC服务器。</p><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><p>首先准备一个Ubuntu 18.04服务器，它可以通过SSH远程或直接操作屏幕上的终端。下载软件需要有互联网连接。对于计算机上的VNC客户端，可以使用VNC Viewer应用程序，例如Royal TSX。<br><img src="https://img-blog.csdnimg.cn/20200803025029411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在本实验中，我们使用了一个带有Ubuntu 18.04（Bionic Beaver）操作系统的服务器，该操作系统使用SSH与本地连接进行访问。</p><h3 id="2-安装VNC服务器"><a href="#2-安装VNC服务器" class="headerlink" title="2. 安装VNC服务器"></a>2. 安装VNC服务器</h3><h4 id="2-1-系统更新"><a href="#2-1-系统更新" class="headerlink" title="2.1 系统更新"></a>2.1 系统更新</h4><p>在继续安装之前，请确保您的服务器已更新到最新版本。</p><pre class=" language-c"><code class="language-c">sudo apt updatesudo apt upgrade <span class="token operator">-</span>y</code></pre><p>如果有更新，则应重新启动服务器，以便可以使用最新的应用程序启动。</p><pre class=" language-c"><code class="language-c">sudo reboot</code></pre><h4 id="2-2-安装TigerVNC"><a href="#2-2-安装TigerVNC" class="headerlink" title="2.2 安装TigerVNC"></a>2.2 安装TigerVNC</h4><p>重新启动服务器后，安装所需的软件包，然后安装TigerVNC。</p><pre class=" language-c"><code class="language-c">sudo apt install xserver<span class="token operator">-</span>xorg<span class="token operator">-</span>coresudo apt install tigervnc<span class="token operator">-</span>standalone<span class="token operator">-</span>server tigervnc<span class="token operator">-</span>xorg<span class="token operator">-</span>extension tigervnc<span class="token operator">-</span>viewersudo apt<span class="token operator">-</span>get install gsfonts<span class="token operator">-</span>x11 xfonts<span class="token operator">-</span>base xfonts<span class="token operator">-</span>75dpi xfonts<span class="token operator">-</span>100dpi</code></pre><h4 id="2-3-安装Gnome-3桌面"><a href="#2-3-安装Gnome-3桌面" class="headerlink" title="2.3 安装Gnome 3桌面"></a>2.3 安装Gnome 3桌面</h4><p>接下来，在Ubuntu服务器上安装Gnome Desktop。</p><pre class=" language-c"><code class="language-c">sudo apt install ubuntu<span class="token operator">-</span>gnome<span class="token operator">-</span>desktop</code></pre><p>启动gnome桌面服务，并确保它在启动时运行。</p><pre class=" language-c"><code class="language-c">sudo systemctl start gdmsudo systemctl enable gdm</code></pre><h4 id="2-4-VNC密码设置"><a href="#2-4-VNC密码设置" class="headerlink" title="2.4 VNC密码设置"></a>2.4 VNC密码设置</h4><p>这一步设置连接到VNC服务器时所使用的VNC密码。使用以下命令:</p><pre class=" language-c"><code class="language-c">vncpasswd</code></pre><p>输入密码，然后确认。如果需要，您可以将密码设置为只读权限。如果不需要，可以按N键确认。</p><p>如果vncpasswd命令无效，请使用vncserver命令，输入密码，然后终止vncserver。</p><pre class=" language-c"><code class="language-c">vncserver <span class="token punctuation">:</span><span class="token number">1</span></code></pre><pre class=" language-c"><code class="language-c">vncserver <span class="token operator">-</span>kill <span class="token punctuation">:</span><span class="token number">1</span></code></pre><h3 id="3-启动脚本设置"><a href="#3-启动脚本设置" class="headerlink" title="3. 启动脚本设置"></a>3. 启动脚本设置</h3><p>接下来，我们将创建一个启动脚本作为初始配置，将在激活VNC服务器时执行。使用<code>vim</code>命令创建<code>~/.vnc/xstartup</code>文件。</p><pre class=" language-c"><code class="language-c">vim <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>vnc<span class="token operator">/</span>xstartup</code></pre><p>然后填写以下代码。</p><pre class=" language-c"><code class="language-c">#<span class="token operator">!</span><span class="token operator">/</span>bin<span class="token operator">/</span>sh<span class="token punctuation">[</span> <span class="token operator">-</span>x <span class="token operator">/</span>etc<span class="token operator">/</span>vnc<span class="token operator">/</span>xstartup <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> exec <span class="token operator">/</span>etc<span class="token operator">/</span>vnc<span class="token operator">/</span>xstartup<span class="token punctuation">[</span> <span class="token operator">-</span>r $HOME<span class="token operator">/</span><span class="token punctuation">.</span>Xresources <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> xrdb $HOME<span class="token operator">/</span><span class="token punctuation">.</span>Xresourcesvncconfig <span class="token operator">-</span>iconic <span class="token operator">&amp;</span>dbus<span class="token operator">-</span>launch <span class="token operator">--</span>exit<span class="token operator">-</span>with<span class="token operator">-</span>session gnome<span class="token operator">-</span>session <span class="token operator">&amp;</span></code></pre><p>保存并退出后，给~/.vnc/xstartup文件添加可执行权限:</p><pre class=" language-c"><code class="language-c">sudo chmod a<span class="token operator">+</span>x <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>vnc<span class="token operator">/</span>xstartup</code></pre><h4 id="3-1-启动VNC服务器"><a href="#3-1-启动VNC服务器" class="headerlink" title="3.1 启动VNC服务器"></a>3.1 启动VNC服务器</h4><p>要运行VNC服务器，可以使用以下命令:</p><pre class=" language-c"><code class="language-c">vncserver <span class="token operator">-</span>localhost no <span class="token operator">-</span>geometry 1920x950 <span class="token operator">-</span>depth <span class="token number">24</span></code></pre><p>上述选项将创建一个会话，允许外部连接具有1920x950像素分辨率和清晰度24.</p><p>在Ubuntu操作系统上，分辨率可以用xrandr -q命令查看.</p><p>您可以根据自己的喜好配置分辨率和清晰度。</p><h3 id="4-连接到VNC-服务器"><a href="#4-连接到VNC-服务器" class="headerlink" title="4. 连接到VNC 服务器"></a>4. 连接到VNC 服务器</h3><p>好了，安装过程完成后，您可以使用我们之前安装的Royal TSX连接到VNC服务器。</p><p>输入服务器的IP地址和使用的端口5901（当VNC进程数为1时）。 </p><p><img src="https://img-blog.csdnimg.cn/20200803025818706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200803025820980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="5-另外的一些事情"><a href="#5-另外的一些事情" class="headerlink" title="5. 另外的一些事情"></a>5. 另外的一些事情</h3><p>有关VNC服务器的一些信息，以便更好地了解VNC服务器的工作原理。</p><p>要查看连接到VNC服务器的用户列表，您可以使用以下命令:<code>vncserver -list</code></p><p>查看VNC服务器是否处于活动状态:</p><pre class=" language-c"><code class="language-c">pgrep Xtigervnc 或者 ss <span class="token operator">-</span>tulpn <span class="token operator">|</span> egrep <span class="token operator">-</span>i <span class="token string">'vnc|590'</span></code></pre><p>5.3 终止VNC会话</p><p>您可以使用以下命令终止VNC会话。</p><pre class=" language-c"><code class="language-c">vncserver <span class="token operator">-</span>kill <span class="token punctuation">:</span><span class="token number">1</span></code></pre><p>以上命令将终止ID为1的VNC会话。您可以自定义ID。 </p><p>或者，您可以使用通配符标记终止所有VNC会话。</p><pre class=" language-c"><code class="language-c">vncserver <span class="token operator">-</span>kill <span class="token punctuation">:</span><span class="token operator">*</span></code></pre><p>运行此命令时，所有连接到VNC的用户都将自动断开连接</p><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>并非所有的Linux应用程序都可以使用命令行界面（CLI）执行，有些应用只能通过桌面完成。 Ubuntu 18 Gnome 3 桌面漂亮且易于使用，安装VNC服务器，使我们可以从任何计算机远程访问桌面并执行桌面活动。</p><h3 id="7-设置系统语言为中文"><a href="#7-设置系统语言为中文" class="headerlink" title="7. 设置系统语言为中文"></a>7. 设置系统语言为中文</h3><h4 id="一、查看当前语言环境"><a href="#一、查看当前语言环境" class="headerlink" title="一、查看当前语言环境"></a>一、查看当前语言环境</h4><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token variable">$LANG</span></code></pre><h4 id="二、安装中文语言包"><a href="#二、安装中文语言包" class="headerlink" title="二、安装中文语言包"></a>二、安装中文语言包</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> language-pack-zh-hans<span class="token function">sudo</span> apt <span class="token function">install</span> language-pack-zh-hant<span class="token function">sudo</span> apt <span class="token function">install</span> language-pack-zh-hant-base<span class="token function">sudo</span> apt <span class="token function">install</span> language-pack-gnome-zh-hant<span class="token function">sudo</span> apt <span class="token function">install</span> language-pack-gnome-zh-hant-base</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token variable"><span class="token variable">`</span>check-language-support -l zh<span class="token variable">`</span></span></code></pre><h4 id="三、修改-etc-default-locale"><a href="#三、修改-etc-default-locale" class="headerlink" title="三、修改/etc/default/locale"></a>三、修改<code>/etc/default/locale</code></h4><p>进入Ubuntu桌面，打开终端，输入下述的命令：</p><pre class=" language-bash"><code class="language-bash">vim /etc/default/locale</code></pre><p>进入文件，修改为：</p><pre class=" language-bash"><code class="language-bash">LANG<span class="token operator">=</span><span class="token string">'en_US'</span> <span class="token comment" spellcheck="true"># 中文可以用‘zh_CN’</span>LANGUAGE<span class="token operator">=</span><span class="token string">'en_US:en'</span> <span class="token comment" spellcheck="true"># 中文可以用‘zh_CN:zh’</span></code></pre><h4 id="四、重启服务"><a href="#四、重启服务" class="headerlink" title="四、重启服务"></a>四、重启服务</h4><p><code>reboot</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> VNC </tag>
            
            <tag> Gnome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Royal TSX 使用VNC登陆Ubuntu18.04远程桌面</title>
      <link href="/post/7b11.html"/>
      <url>/post/7b11.html</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎来到shenhao的AI-大数据技术之旅blog-VNC远程图形桌面的配置之Ubuntu-18-04"><a href="#欢迎来到shenhao的AI-大数据技术之旅blog-VNC远程图形桌面的配置之Ubuntu-18-04" class="headerlink" title="欢迎来到shenhao的AI +大数据技术之旅blog-VNC远程图形桌面的配置之Ubuntu 18.04"></a>欢迎来到shenhao的AI +大数据技术之旅blog-VNC远程图形桌面的配置之Ubuntu 18.04</h1><blockquote><p><strong>Linux云服务器</strong>一般采用SSH连接方式，使用密钥对进行安全地无密码访问。但是SSH连接一般都是字符界面，有时我们需要使用图形界面进行一些复杂操作。本篇文章将以<strong>Ubuntu 18.04</strong>操作系统为例，介绍如何为云服务器安装<strong>VNC Server</strong>，以及如何使用Royal TSX连接云服务器。</p></blockquote><h2 id="VNC服务器搭建"><a href="#VNC服务器搭建" class="headerlink" title="VNC服务器搭建"></a>VNC服务器搭建</h2><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><ul><li>已创建一台Ubuntu 18.04操作系统的云服务器，并且为云服务器绑定弹性公网IP，确保可以连接互联网。</li><li>已在本地macos系统安装Royal RSX客户端，并安装VNC的插件。</li></ul><h3 id="2-安装VNC-Server"><a href="#2-安装VNC-Server" class="headerlink" title="2. 安装VNC Server"></a>2. 安装VNC Server</h3><p>默认情况下，Ubuntu 18.04操作系统没有安装图形环境或VNC Server。本示例中，桌面环境使用Xfce，它是一个精简的轻量化桌面，与Gnome和KDE相比更小巧，并且界面美观、对用户友好，适合云服务器远程连接场景下使用。</p><ol><li><p>通过Royal TSX的ssh插件远程登录云服务器。<br>帐号、密码：您在创建云服务器时设置的密码。</p></li><li><p>执行以下命令，更新软件列表。</p></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> apt update</code></pre><ol start="3"><li>安装Xfce桌面环境。</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> xfce4 xfce4-goodies</code></pre><ol start="4"><li>执行完成后，安装<strong>vnc4server</strong>服务器。</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> vnc4server</code></pre><ol start="5"><li>安装完成后使用<code>vnc4server</code>命令设置安全密码并初始化配置文件：</li></ol><pre class=" language-bash"><code class="language-bash">vnc4server<span class="token operator">>></span><span class="token operator">></span> You will require a password to access you desktop<span class="token operator">>></span><span class="token operator">></span> Password:<span class="token operator">>></span><span class="token operator">></span> Verify:</code></pre><ol start="6"><li>注意最后问是否设置一个只读密码要选否，否则客户端登陆只会看到一个黑屏：<pre class=" language-bash"><code class="language-bash">Would you like to enter a view-only password <span class="token punctuation">(</span>y/n<span class="token punctuation">)</span>? n</code></pre></li></ol><ul><li>密码：长度为6~8个字符。超过8个字符的密码将自动截断。请牢- - 记该密码，VNC Viewer连接云服务器时会使用。</li><li>验证密码：再次输入密码。</li><li>是否创建仅查看密码：使用仅查看密码登录的用户将无法使用鼠标或键盘控制云服务器。此处输入“n”。</li></ul><h3 id="3-配置VNC服务器"><a href="#3-配置VNC服务器" class="headerlink" title="3. 配置VNC服务器"></a>3. 配置VNC服务器</h3><ol><li>首先停止第一个虚拟桌面。</li></ol><pre class=" language-bash"><code class="language-bash">vncserver -kill :1</code></pre><ol start="2"><li>修改xstartup文件。</li></ol><pre class=" language-c"><code class="language-c">vim <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>vnc<span class="token operator">/</span>xstartup</code></pre><p>按“i”进入编辑模式，添加以下内容：</p><pre class=" language-c"><code class="language-c">#<span class="token operator">!</span><span class="token operator">/</span>bin<span class="token operator">/</span>sh<span class="token macro property"># Uncomment the following two lines for normal desktop:</span><span class="token macro property"># unset SESSION_MANAGER</span><span class="token macro property"># exec /etc/X11/xinit/xinitrc</span><span class="token punctuation">[</span> <span class="token operator">-</span>x <span class="token operator">/</span>etc<span class="token operator">/</span>vnc<span class="token operator">/</span>xstartup <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> exec <span class="token operator">/</span>etc<span class="token operator">/</span>vnc<span class="token operator">/</span>xstartup<span class="token punctuation">[</span> <span class="token operator">-</span>r $HOME<span class="token operator">/</span><span class="token punctuation">.</span>Xresources <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> xrdb $HOME<span class="token operator">/</span><span class="token punctuation">.</span>Xresourcesxsetroot <span class="token operator">-</span>solid greyvncconfig <span class="token operator">-</span>iconic <span class="token operator">&amp;</span>x<span class="token operator">-</span>terminal<span class="token operator">-</span>emulator <span class="token operator">-</span>geometry 80x24<span class="token operator">+</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">10</span> <span class="token operator">-</span>ls <span class="token operator">-</span>title <span class="token string">"$VNCDESKTOP"</span> <span class="token operator">&amp;</span>unset SESSION_MANAGERunset DBUGS_SESSION_BUS_ADDRESSstartxfce4 <span class="token operator">&amp;</span></code></pre><p>其中，前两行是销毁被侵占的环境变量，最后一行表明使用的为xfce的桌面系统。<br>3. 为了保证VNC服务正常启动，需要配置可执行。</p><pre class=" language-c"><code class="language-c">sudo chmod <span class="token operator">+</span>x <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>vnc<span class="token operator">/</span>xstartup</code></pre><h2 id="正式开启VNC服务"><a href="#正式开启VNC服务" class="headerlink" title="正式开启VNC服务"></a>正式开启VNC服务</h2><p>执行<code>vnc4server</code>命令正式开启VNC服务。默认在5901端口上启动默认服务器实例。该端口为显示端口，由VNC称为:1。实质上VNC使用的TCP端口从5900开始，尾数与桌面号相关。1号桌面为5901，2号桌面为5902，依次类推。</p><p>手动启动VNC服务时可以直接指定分辨率与桌面号，命令如下：</p><pre class=" language-c"><code class="language-c">vnc4server <span class="token operator">-</span>geometry 1920x1080 <span class="token punctuation">:</span><span class="token number">1</span></code></pre><p>停止服务的命令为：</p><pre class=" language-c"><code class="language-c">vnc4server <span class="token operator">-</span>kill <span class="token punctuation">:</span><span class="token number">1</span></code></pre><h2 id="关闭TCP端口的防火墙"><a href="#关闭TCP端口的防火墙" class="headerlink" title="关闭TCP端口的防火墙"></a>关闭TCP端口的防火墙</h2><p>在远程连接VNC服务之前，我们还需要关闭相应TCP端口的防火墙，命令如下：</p><pre class=" language-c"><code class="language-c">sudo ufw allow <span class="token number">5901</span></code></pre><h2 id="云服务器控制台配置"><a href="#云服务器控制台配置" class="headerlink" title="云服务器控制台配置"></a>云服务器控制台配置</h2><ol><li>登录云服务器管理控制台。</li><li>单击弹性云服务器名称，进入详情页面。</li><li>在“安全组”页签，单击“更改安全组规则”，放行5901端口。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdXBwb3J0Lmh1YXdlaWNsb3VkLmNvbS9iZXN0cHJhY3RpY2UtZWNzL3poLWNuX2ltYWdlXzAyMjE0NzQxNTQucG5n?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"><blockquote><p>说明：<br>如果4中回显的日志文件为“xxx:2.log”，则需要放行5902端口；如果为“xxx:3.log”，则需要放行5903端口，以此类推。</p></blockquote></li></ol><h2 id="使用VNC-Viewer连接云服务器"><a href="#使用VNC-Viewer连接云服务器" class="headerlink" title="使用VNC Viewer连接云服务器"></a>使用VNC Viewer连接云服务器</h2><p>在本地PC打开Royal TSX客户端，输入云服务器的弹性公网IP，端口号为5901，输入root以及密码，单击“Apply &amp; Close”。</p><p><img src="https://img-blog.csdnimg.cn/20200803020844911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200803020844867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>登陆链接<br><img src="https://img-blog.csdnimg.cn/20200803020845129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcwNjM0Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><a href="https://baijiahao.baidu.com/s?id=1645514514391414083&wfr=spider&for=pc">Ubuntu Desktop 18.04 Gnome桌面配置VNC Server</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Royal TSX </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> VNC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客部署到码云和 Coding</title>
      <link href="/post/e7ac.html"/>
      <url>/post/e7ac.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-博客部署到码云和-Coding"><a href="#Hexo-博客部署到码云和-Coding" class="headerlink" title="Hexo 博客部署到码云和 Coding"></a>Hexo 博客部署到码云和 Coding</h1><h2 id="部署到-Coding-平台"><a href="#部署到-Coding-平台" class="headerlink" title="部署到 Coding 平台"></a>部署到 Coding 平台</h2><h3 id="1-首先去官网进行注册，也可以用第三方微信进行注册。"><a href="#1-首先去官网进行注册，也可以用第三方微信进行注册。" class="headerlink" title="1. 首先去官网进行注册，也可以用第三方微信进行注册。"></a>1. 首先去官网进行注册，也可以用第三方微信进行注册。</h3><pre><code>![](https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/Hexo_1.png)</code></pre><h3 id="2-注册完成之后就会进入主页面，然后创建新项目，如下图所示"><a href="#2-注册完成之后就会进入主页面，然后创建新项目，如下图所示" class="headerlink" title="2. 注册完成之后就会进入主页面，然后创建新项目，如下图所示"></a>2. 注册完成之后就会进入主页面，然后创建新项目，如下图所示</h3><blockquote><p>项目名称：与你的用户名相同，用户名就是你的团队名</p></blockquote><p>   <img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/Hexo_2.png"></p><hr><ul><li>代码托管项目：用于托管代码仓库，支持多个仓库，并可选择开启 CI/CD 和制品库功能</li><li>项目管理项目：支持 Scrum 敏捷管理和传统任务管理项目，包含需求、任务和缺陷</li><li>DevOps 项目：包含项目管理、代码托管、CI/CD 和制品库等功能，提供完整的研发流程</li></ul><hr><p>在这里我们选择第三个，DevOps 项目，这个含有构建与部署功能。<br>选择第三个 DevOps 项目后，会出现下面的页面：</p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/Hexo_3.png"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/Hexo_4.png"></p><h3 id="3-添加部署公钥"><a href="#3-添加部署公钥" class="headerlink" title="3. 添加部署公钥"></a>3. 添加部署公钥</h3><pre><code>在个人设置里面，点击**SSH 公钥** 。点击**新增公钥**。![](https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/Hexo_5.png)</code></pre><p>​    <img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/Hexo_6.png"></p><ul><li><p>公钥名称：自定义</p></li><li><p>公钥内容：可以使用之前连接 GitHub 的公钥，在本地的 <code>C:\Users\你的电脑账户名\.ssh</code>，我的为 <code>C:\Users\Administrator\.ssh</code>，用文本编辑器打开 id_rsa.pub，将里面的内容复制粘贴到此处即可。</p></li><li><p>公钥有效期：选择永久有效</p></li></ul><p>点击添加，然后回弹出一个密码框，输入你的用户密码验证一下即可，然后打开 cmd 控制台输入 ssh -T <a href="mailto:&#103;&#105;&#x74;&#64;&#x65;&#x2e;&#99;&#111;&#x64;&#105;&#x6e;&#x67;&#x2e;&#x6e;&#101;&#116;">&#103;&#105;&#x74;&#64;&#x65;&#x2e;&#99;&#111;&#x64;&#105;&#x6e;&#x67;&#x2e;&#x6e;&#101;&#116;</a>，第一次建立连接会要求信任主机，输入相关的用户名或者密码，在控制台输入验证，验证成功即可。</p><p>然后复制你的项目地址，粘贴到站点目录下的配置文件，如图所示：</p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/Hexo_7.png"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/Hexo_8.png"></p><p>然后再执行 <code>hexo clean &amp;&amp; hexo g -d</code> 部署到 coding，紧接着，打开你的 coding 项目管理页，进行静态网站构建，页面如下，按图中步骤操作即可：</p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/Hexo_9.png"></p><p>点击保存，就会进入下一个页面：</p><p>点击立即部署，当出现如下的页面效果，就说明部署成功。</p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/Hexo_10.png"></p><p>点击图中的访问地址就可以查看效果了。</p><h3 id="4-绑定域名"><a href="#4-绑定域名" class="headerlink" title="4. 绑定域名"></a>4. 绑定域名</h3><p>在绑定域名之前首先需要将访问地址添加到 DNS 域名解析之中。</p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/20200128164410.png"></p><p>我的添加记录为：</p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/20200128164514.png"></p><p>线路类型我选择的是境内，也就是说，当境内有人访问时，会通过国内的 Coding 平台。</p><p>然后点击上一张图所显示的设置按钮，进入静态网站设置页面：</p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/2020-01-28_13-57-11.png"></p><p>在绑定新域名下的输入框，输入你的域名，然后点击绑定即可。</p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/20200128164204.png"></p><blockquote><p>如果再申请 Coding 的证书的过程中，申请失败，请先到域名管理控制台停止对 GitHub 有关的解析，然后再申请，申请成功后，再开启有关对 GitHub 的解析即可。</p></blockquote><h2 id="部署到码云"><a href="#部署到码云" class="headerlink" title="部署到码云"></a>部署到码云</h2><h3 id="1-同样，先去码云官网进行注册，注册完成后，会跳转到如下的页面："><a href="#1-同样，先去码云官网进行注册，注册完成后，会跳转到如下的页面：" class="headerlink" title="1. 同样，先去码云官网进行注册，注册完成后，会跳转到如下的页面："></a>1. 同样，先去码云官网进行注册，注册完成后，会跳转到如下的页面：</h3><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/18.png"></p><h3 id="2-开始新建仓库，如上一张图的操作步骤，会出现如下效果："><a href="#2-开始新建仓库，如上一张图的操作步骤，会出现如下效果：" class="headerlink" title="2. 开始新建仓库，如上一张图的操作步骤，会出现如下效果："></a>2. 开始新建仓库，如上一张图的操作步骤，会出现如下效果：<img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/19.png"></h3><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/22.png"></p><blockquote><p>注意：仓库名称必须要和用户名一样，否则最后部署出来会出现无样式的效果或者其他不正常的显示。</p></blockquote><h3 id="3-添加公钥"><a href="#3-添加公钥" class="headerlink" title="3. 添加公钥"></a>3. 添加公钥</h3><p>点击管理 —&gt; 部署公钥管理 —&gt; 新增部署公钥，添加公钥的内容也是之前部署到 GitHub 上添加的公钥</p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/20200128165859.png"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/2020-01-28_14-12-50.png"></p><h3 id="4-部署到码云"><a href="#4-部署到码云" class="headerlink" title="4. 部署到码云"></a>4. 部署到码云</h3><p>将项目地址复制粘贴到配置文件上，如下图所示：</p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/23.png"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/15.png"></p><p>然后执行<code> hexo clean &amp;&amp; hexo g -d</code>，部署成功后，点击服务 —&gt;Gitee Pages，进入下面的页面：</p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/20.png"></p><p><img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/21.png"></p><p>第一次设置 Gitee Pages 的效果不是我图中所显示的，最后的设置效果就是这样的，当显示图中红色文字已开启 Gitee PAges 服务, 即部署成功，点击网址，查看效果。</p><h2 id="国内-Coding，国外-Github"><a href="#国内-Coding，国外-Github" class="headerlink" title="国内 Coding，国外 Github"></a>国内 Coding，国外 Github</h2><p>在 DNS 域名解析中设置线路类型即可：</p><p>我的为：<img src="https://gitee.com/shenhao-stu/picgo/raw/master/Jisoo/20200128172347.png"></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Coding </tag>
            
            <tag> Gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Picgo图床配置</title>
      <link href="/post/bfd4.html"/>
      <url>/post/bfd4.html</url>
      
        <content type="html"><![CDATA[<h1 id="PicGo图床配置教程"><a href="#PicGo图床配置教程" class="headerlink" title="PicGo图床配置教程"></a>PicGo图床配置教程</h1><h2 id="一、什么是图床"><a href="#一、什么是图床" class="headerlink" title="一、什么是图床"></a>一、什么是图床</h2><p>图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。 </p><p>简单来说就是：在文章中引用指定网址显示图片。 </p><p><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/1.png"></p><p><font color="red">平常我们都是在网络上复制粘贴网络图片的地址，太out了，如何快速引用本地图片呢？？</font></p><h2 id="二、配置教程"><a href="#二、配置教程" class="headerlink" title="二、配置教程"></a>二、配置教程</h2><h3 id="1-获取Token"><a href="#1-获取Token" class="headerlink" title="1.获取Token"></a>1.获取Token</h3><blockquote><p> github云端仓库位置： 延续上一次cdn的仓库失败。（建议新建一个仓库，发布过release版本号的仓库会使用异常）</p></blockquote><p>1.进入设置Setting<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/3.png"><br>2.选择开发者设置Developer setting<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/2.png"><br>3.选择个人数据帧Personal access tokens，生成新的数据帧 Generate new token<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/4.png"><br>4.命名为picgo（图床），赋予仓库权限<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/5.png"><br>5.最后点击Generate token即可看到显示的token页面，<strong>它只会显示一次，关闭页面后再打开这个页面就不会显示了。</strong> 复制token值粘贴到文本文档中，先保存下来，后面配置PicGo要用到。<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/6.png"></p><h3 id="2-本地安装图片上传工具"><a href="#2-本地安装图片上传工具" class="headerlink" title="2.本地安装图片上传工具"></a>2.本地安装图片上传工具</h3><ol><li><p>首先下载PicGo，图片上传工具PicGo下载址:<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p></li><li><p>安装配置PicGo<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/7.png"></p></li></ol><ul><li>设定仓库名：这个是刚刚第一步所新建仓库的名称，我的为cdn，此处填写格式username/repo。 </li><li>设定分支名：master，采用默认分支即可 </li><li>设定Token：此处填写上一步得到的Token，添加到输入框即可。</li><li>指定存储路径：自定义，例：images/，相当于在刚刚新建的仓库下新建了一个文件夹。 </li><li>设定自定义域名：cdn加速格式：<a href="https://cdn.jsdelivr.net/gh/username/repo">https://cdn.jsdelivr.net/gh/username/repo</a></li><li>username为GitHub用户名，repo为新建的仓库，用于存储图片 </li></ul><h2 id="三、上传方法"><a href="#三、上传方法" class="headerlink" title="三、上传方法"></a>三、上传方法</h2><ol><li><p>快捷键上传 </p></li><li><p>拖拽上传<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/8.png"><br>上传后，云端图片显示：<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/9.png"></p></li><li><p>使用方法：选择<strong>相册</strong>，可<strong>复制、修改链接、删除</strong>图片（不能删除github上的图片，需要手动删除）：<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/11.png"> </p></li></ol><h2 id="四、解决无法上传的问题"><a href="#四、解决无法上传的问题" class="headerlink" title="四、解决无法上传的问题"></a>四、解决无法上传的问题</h2><p>进入PicGo设置，找到设置Server，并选择关闭<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/10.png"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo个性化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Picgo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-2020详细教程</title>
      <link href="/post/3254.html"/>
      <url>/post/3254.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-2020详细教程-lt-配合千锋Java学习营-gt"><a href="#Docker-2020详细教程-lt-配合千锋Java学习营-gt" class="headerlink" title="Docker-2020详细教程&lt;配合千锋Java学习营&gt;"></a>Docker-2020详细教程&lt;配合千锋Java学习营&gt;</h1><h2 id="一、Docker介绍"><a href="#一、Docker介绍" class="headerlink" title="一、Docker介绍"></a>一、Docker介绍</h2><h3 id="1-下载Dcoker依的赖环境"><a href="#1-下载Dcoker依的赖环境" class="headerlink" title="1.下载Dcoker依的赖环境"></a>1.下载Dcoker依的赖环境</h3><pre class=" language-bash"><code class="language-bash">想安装Docker，需要先将依赖的环境全部下载下来，就像Maven依赖JDK一样yum -y <span class="token function">install</span> yum-utils device-mapper-persistent-data lvm2</code></pre><h3 id="2-指定Docker镜像源"><a href="#2-指定Docker镜像源" class="headerlink" title="2.指定Docker镜像源"></a>2.指定Docker镜像源</h3><pre class=" language-powershell"><code class="language-powershell">默认下载Docker会去国外服务器下载，速度较慢，可以设置为阿里云镜像源，速度更快yum<span class="token operator">-</span>config<span class="token operator">-</span>manager <span class="token operator">--</span>add<span class="token operator">-</span>repo http:<span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>docker<span class="token operator">-</span>ce<span class="token operator">/</span>linux<span class="token operator">/</span>centos<span class="token operator">/</span>docker<span class="token operator">-</span>ce<span class="token punctuation">.</span>repo</code></pre><h3 id="3-安装Docker"><a href="#3-安装Docker" class="headerlink" title="3.安装Docker"></a>3.安装Docker</h3><pre class=" language-powershell"><code class="language-powershell">yum makecache fastyum <span class="token operator">-</span>y install docker<span class="token operator">-</span>ce</code></pre><h3 id="4-启动Docker并测试"><a href="#4-启动Docker并测试" class="headerlink" title="4.启动Docker并测试"></a>4.启动Docker并测试</h3><pre class=" language-powershell"><code class="language-powershell">安装成功后，需要手动启动，设置为开机启动，并测试一下 Docker<span class="token comment" spellcheck="true">#启动docker服务</span>systemctl <span class="token function">start</span> docker<span class="token comment" spellcheck="true">#设置开机自动启动</span>systemctl enable docker<span class="token comment" spellcheck="true">#测试</span>docker run hello<span class="token operator">-</span>world</code></pre><h2 id="二、Docker的中央仓库"><a href="#二、Docker的中央仓库" class="headerlink" title="二、Docker的中央仓库"></a>二、Docker的中央仓库</h2><pre class=" language-powershell"><code class="language-powershell">1<span class="token punctuation">.</span>Docker官方的中央仓库：这个仓库是镜像最全的，但是下载速度较慢。https:<span class="token operator">/</span><span class="token operator">/</span>hub<span class="token punctuation">.</span>docker<span class="token punctuation">.</span>com<span class="token operator">/</span>2<span class="token punctuation">.</span>国内的镜像网站：网易蜂巢，daoCloud等，下载速度快，但是镜像相对不全。https:<span class="token operator">/</span><span class="token operator">/</span>c<span class="token punctuation">.</span>163yun<span class="token punctuation">.</span>com<span class="token operator">/</span>hub<span class="token comment" spellcheck="true">#/home </span>http:<span class="token operator">/</span><span class="token operator">/</span>hub<span class="token punctuation">.</span>daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span> （推荐使用）3<span class="token punctuation">.</span>在公司内部会采用私服的方式拉取镜像（添加配置）<span class="token comment" spellcheck="true">#需要创建 /etc/docker/daemon.json，并添加如下内容</span>&amp;<span class="token comment" spellcheck="true">#123;</span>    <span class="token string">"registry-mirrors"</span>:<span class="token punctuation">[</span><span class="token string">"https://registry.docker-cn.com"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token string">"insecure-registries"</span>:<span class="token punctuation">[</span><span class="token string">"ip:port"</span><span class="token punctuation">]</span>&amp;<span class="token comment" spellcheck="true">#125;</span><span class="token comment" spellcheck="true">#重启两个服务</span>systemctl daemon<span class="token operator">-</span>reloadsystemctl restart docker</code></pre><h2 id="三、镜像的操作"><a href="#三、镜像的操作" class="headerlink" title="三、镜像的操作"></a>三、镜像的操作</h2><h3 id="1-拉取镜像"><a href="#1-拉取镜像" class="headerlink" title="1.拉取镜像"></a>1.拉取镜像</h3><pre class=" language-powershell"><code class="language-powershell">从中央仓库拉取镜像到本地docker pull 镜像名称<span class="token punctuation">[</span>:tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#举个栗子:docker pull daocloud.io/library/tomcat:8.5.15-jre8</span></code></pre><h3 id="2-查看本地全部镜像"><a href="#2-查看本地全部镜像" class="headerlink" title="2.查看本地全部镜像"></a>2.查看本地全部镜像</h3><pre class=" language-powershell"><code class="language-powershell">查看本地已经安装过的镜像信息，包含标识，名称，版本，更新时间，大小docker images</code></pre><h3 id="3-删除本地镜像"><a href="#3-删除本地镜像" class="headerlink" title="3.删除本地镜像"></a>3.删除本地镜像</h3><pre class=" language-powershell"><code class="language-powershell">镜像会占用磁盘空间，可以直接手动删除，标识通过查看获取docker rmi 镜像的标识</code></pre><h3 id="4-镜像的导入导出"><a href="#4-镜像的导入导出" class="headerlink" title="4.镜像的导入导出"></a>4.镜像的导入导出</h3><pre class=" language-powershell"><code class="language-powershell">如果因为网络原因可以通过硬盘的方式传输镜像，虽然不规范，但是有效，但是这种方式导出的镜像名称和版本都是null，需要手动修改<span class="token comment" spellcheck="true">#将本地的镜像导出</span>docker save <span class="token operator">-</span>o 导出的路径 镜像id<span class="token comment" spellcheck="true">#加载本地的镜像文件</span>docker load <span class="token operator">-</span>i 镜像文件<span class="token comment" spellcheck="true">#修改镜像文件</span>docker tag 镜像id 新镜像名称：版本</code></pre><h2 id="四、容器的操作"><a href="#四、容器的操作" class="headerlink" title="四、容器的操作"></a>四、容器的操作</h2><h3 id="1-运行容器"><a href="#1-运行容器" class="headerlink" title="1.运行容器"></a>1.运行容器</h3><pre class=" language-powershell"><code class="language-powershell">运行容器需要定制具体镜像，如果镜像不存在，会直接下载<span class="token comment" spellcheck="true">#简单操作</span>docker run 镜像的标识<span class="token punctuation">|</span>镜像的名称<span class="token punctuation">[</span>:tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#常用的参数</span>docker run <span class="token operator">-</span>d <span class="token operator">-</span>p 宿主机端口:容器端口 <span class="token operator">--</span>name 容器名称 镜像的标识<span class="token punctuation">|</span>镜像名称<span class="token punctuation">[</span>:tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#-d:代表后台运行容器</span><span class="token comment" spellcheck="true">#-p 宿主机端口:容器端口：为了映射当前Linux的端口和容器的端口</span><span class="token comment" spellcheck="true">#--name 容器名称:指定容器的名称</span></code></pre><h3 id="2-查看正在运行的容器"><a href="#2-查看正在运行的容器" class="headerlink" title="2.查看正在运行的容器"></a>2.查看正在运行的容器</h3><pre class=" language-powershell"><code class="language-powershell">查看全部正在运行的容器信息docker <span class="token function">ps</span> <span class="token punctuation">[</span><span class="token operator">-</span>qa<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#-a 查看全部的容器，包括没有运行</span><span class="token comment" spellcheck="true">#-q 只查看容器的标识</span></code></pre><h3 id="3-查看容器日志"><a href="#3-查看容器日志" class="headerlink" title="3.查看容器日志"></a>3.查看容器日志</h3><pre class=" language-powershell"><code class="language-powershell">查看容器日志，以查看容器运行的信息docker logs <span class="token operator">-</span>f 容器id<span class="token comment" spellcheck="true">#-f：可以滚动查看日志的最后几行</span></code></pre><h3 id="4-进入容器的内部"><a href="#4-进入容器的内部" class="headerlink" title="4.进入容器的内部"></a>4.进入容器的内部</h3><pre class=" language-powershell"><code class="language-powershell">可以进入容器的内部进行操作docker exec <span class="token operator">-</span>it 容器id bash</code></pre><h3 id="5-复制内容到容器"><a href="#5-复制内容到容器" class="headerlink" title="5.复制内容到容器"></a>5.复制内容到容器</h3><pre class=" language-powershell"><code class="language-powershell">将宿主机的文件复制到容器内部的指定目录docker <span class="token function">cp</span> 文件名称 容器id:容器内部路径</code></pre><h3 id="6-重启-amp-启动-amp-停止-amp-删除容器"><a href="#6-重启-amp-启动-amp-停止-amp-删除容器" class="headerlink" title="6.重启&amp;启动&amp;停止&amp;删除容器"></a>6.重启&amp;启动&amp;停止&amp;删除容器</h3><pre class=" language-powershell"><code class="language-powershell">容器的启动，停止，删除等操作，后续会经常使用到<span class="token comment" spellcheck="true">#重新启动容器</span>docker restart 容器id<span class="token comment" spellcheck="true">#启动停止运行的容器</span>docker <span class="token function">start</span> 容器id<span class="token comment" spellcheck="true">#停止指定的容器(删除容器前，需要先停止容器)</span>docker stop 容器id<span class="token comment" spellcheck="true">#停止全部容器</span>docker stop $<span class="token punctuation">(</span>docker <span class="token function">ps</span> <span class="token operator">-</span>qa<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#删除指定容器</span>docker <span class="token function">rm</span> 容器id<span class="token comment" spellcheck="true">#删除全部容器</span>docker <span class="token function">rm</span> $<span class="token punctuation">(</span>docker <span class="token function">ps</span> <span class="token operator">-</span>qa<span class="token punctuation">)</span></code></pre><h2 id="五、Docker应用"><a href="#五、Docker应用" class="headerlink" title="五、Docker应用"></a>五、Docker应用</h2><h3 id="1-docker安装tomcat"><a href="#1-docker安装tomcat" class="headerlink" title="1.docker安装tomcat"></a>1.docker安装tomcat</h3><pre class=" language-powershell"><code class="language-powershell">运行Tomcat容器，为部署ssm工程做准备docker run <span class="token operator">-</span>d <span class="token operator">-</span>p 8080:8080 <span class="token operator">--</span>name tomcat  daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span>library<span class="token operator">/</span>tomcat:8<span class="token punctuation">.</span>5<span class="token punctuation">.</span>15<span class="token operator">-</span>jre8<span class="token comment" spellcheck="true">#或者已经下载了tomcat镜像</span>docker run <span class="token operator">-</span>d <span class="token operator">-</span>p 8080:8080 <span class="token operator">--</span>name tomcat 镜像的标识</code></pre><h3 id="2-运行MySQL容器"><a href="#2-运行MySQL容器" class="headerlink" title="2.运行MySQL容器"></a>2.运行MySQL容器</h3><pre class=" language-powershell"><code class="language-powershell">docker run <span class="token operator">-</span>d <span class="token operator">-</span>p 3306:3306 <span class="token operator">--</span>name mysql <span class="token operator">-</span>e MYSQL_ROOT_PASSWORD=root daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span>library<span class="token operator">/</span>mysql:5<span class="token punctuation">.</span>7<span class="token punctuation">.</span>4</code></pre><h3 id="3-部署ssm工程"><a href="#3-部署ssm工程" class="headerlink" title="3.部署ssm工程"></a>3.部署ssm工程</h3><pre class=" language-powershell"><code class="language-powershell">修改SSM工程环境，设置为Linux中Docker容器的信息通过Maven的package重新打成war包将Windows下的war包复制到Linux中通过docker命令将宿主机的war包复制到容器内部docker <span class="token function">cp</span> 文件名称 容器id:容器内部路径测试访问SSM工程</code></pre><h2 id="六、数据卷"><a href="#六、数据卷" class="headerlink" title="六、数据卷"></a>六、数据卷</h2><blockquote><p>为了部署SSM的工程，需要使用到cp的命令将宿主机内的ssm.war文件复制到容器内部。 数据卷：将宿主机的一个目录映射到容器的一个目录中。</p><p>可以在宿主机中操作目录中的内容，那么容器内部映射的文件，也会跟着一起改变。</p></blockquote><h3 id="1-创建数据卷"><a href="#1-创建数据卷" class="headerlink" title="1.创建数据卷"></a>1.创建数据卷</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#创建数据卷后，默认会存放在一个目录下/var/lib/docker/volumes/数据卷名称/_data</span>docker volume create 数据卷名称</code></pre><h3 id="2-查看全部数据卷"><a href="#2-查看全部数据卷" class="headerlink" title="2.查看全部数据卷"></a>2.查看全部数据卷</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#查看全部数据卷信息</span>docker volume <span class="token function">ls</span></code></pre><h3 id="3-查看数据卷详情"><a href="#3-查看数据卷详情" class="headerlink" title="3.查看数据卷详情"></a>3.查看数据卷详情</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#查看数据卷的详细信息，可以查询到存放的路径，创建时间等等</span>docker volume inspect 数据卷名称</code></pre><h3 id="4-删除数据卷"><a href="#4-删除数据卷" class="headerlink" title="4.删除数据卷"></a>4.删除数据卷</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#删除指定的数据卷</span>docker volume <span class="token function">rm</span> 数据卷名称</code></pre><h3 id="5-容器映射数据卷"><a href="#5-容器映射数据卷" class="headerlink" title="5.容器映射数据卷"></a>5.容器映射数据卷</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#通过数据卷名称映射，如果数据卷不存在。Docker会帮你自动创建，会将容器内部自带的文件，存储在默认的存放路径中。</span>docker run <span class="token operator">-</span>d <span class="token operator">-</span>p 8080:8080 <span class="token operator">--</span>name tomcat <span class="token operator">-</span>v 数据卷名称:容器内部的路径 镜像id<span class="token comment" spellcheck="true">#通过路径映射数据卷，直接指定一个路径作为数据卷的存放位置。但是这个路径下是空的。</span>docker run <span class="token operator">-</span>d <span class="token operator">-</span>p 8080:8080 <span class="token operator">--</span>name tomcat <span class="token operator">-</span>v 路径<span class="token punctuation">(</span><span class="token operator">/</span>root<span class="token operator">/</span>自己创建的文件夹<span class="token punctuation">)</span>:容器内部的路径 镜像id</code></pre><h2 id="七、Dockerfile自定义镜像"><a href="#七、Dockerfile自定义镜像" class="headerlink" title="七、Dockerfile自定义镜像"></a>七、Dockerfile自定义镜像</h2><h3 id="1-Dockerfile"><a href="#1-Dockerfile" class="headerlink" title="1.Dockerfile"></a>1.Dockerfile</h3><pre class=" language-powershell"><code class="language-powershell">创建自定义镜像就需要创建一个Dockerfiler<span class="token punctuation">,</span>如下为Dockerfile的语言<span class="token keyword">from</span>：指定当前自定义镜像依赖的环境<span class="token function">copy</span>：将相对路径下的内容复制到自定义镜像中workdir：声明镜像的默认工作目录run：执行的命令，可以编写多个cmd：需要执行的命令（在workdir下执行的，cmd可以写多个，只以最后一个为准）<span class="token comment" spellcheck="true">#示例：</span><span class="token keyword">from</span> daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span>library<span class="token operator">/</span>tomcat:8<span class="token punctuation">.</span>5<span class="token punctuation">.</span>15<span class="token operator">-</span>jre8<span class="token function">copy</span> ssm<span class="token punctuation">.</span>war <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>tomcat<span class="token operator">/</span>webapps</code></pre><h2 id="2-通过Dockerfile制作镜像"><a href="#2-通过Dockerfile制作镜像" class="headerlink" title="2.通过Dockerfile制作镜像"></a>2.通过Dockerfile制作镜像</h2><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#编写完Dockerfile后需要通过命令将其制作为镜像，并且要在Dockerfile的当前目录下，之后即可在镜像中查看到指定的镜像信息，注意最后的 .</span>docker build <span class="token operator">-</span>t 镜像名称<span class="token punctuation">[</span>:tag<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token operator">/</span></code></pre><h2 id="八、Docker-Compose"><a href="#八、Docker-Compose" class="headerlink" title="八、Docker-Compose"></a>八、Docker-Compose</h2><h3 id="1-下载并安装Docker-Compose"><a href="#1-下载并安装Docker-Compose" class="headerlink" title="1.下载并安装Docker-Compose"></a>1.下载并安装Docker-Compose</h3><h4 id="1-1下载Docker-Compose"><a href="#1-1下载Docker-Compose" class="headerlink" title="1.1下载Docker-Compose"></a>1.1下载Docker-Compose</h4><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#去github官网搜索docker-compose，下载1.24.1版本的Docker-Compose</span>下载路径：https:<span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>docker<span class="token operator">/</span>compose<span class="token operator">/</span>releases<span class="token operator">/</span>download<span class="token operator">/</span>1<span class="token punctuation">.</span>24<span class="token punctuation">.</span>1<span class="token operator">/</span>docker<span class="token operator">-</span>compose<span class="token operator">-</span>Linux<span class="token operator">-</span>x86_64</code></pre><h4 id="1-2设置权限"><a href="#1-2设置权限" class="headerlink" title="1.2设置权限"></a>1.2设置权限</h4><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#需要将DockerCompose文件的名称修改一下，给予DockerCompose文件一个可执行的权限</span><span class="token function">mv</span> docker<span class="token operator">-</span>compose<span class="token operator">-</span>Linux<span class="token operator">-</span>x86_64 docker<span class="token operator">-</span>composechmod 777 docker<span class="token operator">-</span>compose</code></pre><h4 id="1-3配置环境变量"><a href="#1-3配置环境变量" class="headerlink" title="1.3配置环境变量"></a>1.3配置环境变量</h4><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#方便后期操作，配置一个环境变量</span><span class="token comment" spellcheck="true">#将docker-compose文件移动到了/usr/local/bin，修改了/etc/profile文件，给/usr/local/bin配置到了PATH中</span><span class="token function">mv</span> docker<span class="token operator">-</span>compose <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>binvi <span class="token operator">/</span>etc<span class="token operator">/</span>profile<span class="token comment" spellcheck="true">#添加内容：export PATH=$JAVA_HOME:/usr/local/bin:$PATH</span>source <span class="token operator">/</span>etc<span class="token operator">/</span>profile</code></pre><h4 id="1-4测试"><a href="#1-4测试" class="headerlink" title="1.4测试"></a>1.4测试</h4><pre class=" language-powershell"><code class="language-powershell">在任意目录下输入docker<span class="token operator">-</span>compose</code></pre><h3 id="2-Docker-Compose管理MySQL和Tomcat容器"><a href="#2-Docker-Compose管理MySQL和Tomcat容器" class="headerlink" title="2.Docker-Compose管理MySQL和Tomcat容器"></a>2.Docker-Compose管理MySQL和Tomcat容器</h3><pre class=" language-powershell"><code class="language-powershell">yml文件以key:value方式来指定配置信息多个配置信息以换行<span class="token operator">+</span>缩进的方式来区分在docker<span class="token operator">-</span>compose<span class="token punctuation">.</span>yml文件中，不要使用制表符version: <span class="token string">'3.1'</span>services:  mysql:           <span class="token comment" spellcheck="true"># 服务的名称</span>    restart: always   <span class="token comment" spellcheck="true"># 代表只要docker启动，那么这个容器就跟着一起启动</span>    image: daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span>library<span class="token operator">/</span>mysql:5<span class="token punctuation">.</span>7<span class="token punctuation">.</span>4  <span class="token comment" spellcheck="true"># 指定镜像路径</span>    container_name: mysql  <span class="token comment" spellcheck="true"># 指定容器名称</span>    ports:      <span class="token operator">-</span> 3306:3306   <span class="token comment" spellcheck="true">#  指定端口号的映射</span>    environment:      MYSQL_ROOT_PASSWORD: root   <span class="token comment" spellcheck="true"># 指定MySQL的ROOT用户登录密码</span>      TZ: Asia<span class="token operator">/</span>Shanghai        <span class="token comment" spellcheck="true"># 指定时区</span>    volumes:     <span class="token operator">-</span> <span class="token operator">/</span>opt<span class="token operator">/</span>docker_mysql_tomcat<span class="token operator">/</span>mysql_data:<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>mysql   <span class="token comment" spellcheck="true"># 映射数据卷</span>  tomcat:    restart: always    image: daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span>library<span class="token operator">/</span>tomcat:8<span class="token punctuation">.</span>5<span class="token punctuation">.</span>15<span class="token operator">-</span>jre8    container_name: tomcat    ports:      <span class="token operator">-</span> 8080:8080    environment:      TZ: Asia<span class="token operator">/</span>Shanghai    volumes:      <span class="token operator">-</span> <span class="token operator">/</span>opt<span class="token operator">/</span>docker_mysql_tomcat<span class="token operator">/</span>tomcat_webapps:<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>tomcat<span class="token operator">/</span>webapps      <span class="token operator">-</span> <span class="token operator">/</span>opt<span class="token operator">/</span>docker_mysql_tomcat<span class="token operator">/</span>tomcat_logs:<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>tomcat<span class="token operator">/</span>logs</code></pre><h3 id="3-使用docker-compose命令管理容器"><a href="#3-使用docker-compose命令管理容器" class="headerlink" title="3.使用docker-compose命令管理容器"></a>3.使用docker-compose命令管理容器</h3><pre class=" language-powershell"><code class="language-powershell">在使用docker<span class="token operator">-</span>compose的命令时，默认会在当前目录下找docker<span class="token operator">-</span>compose<span class="token punctuation">.</span>yml文件<span class="token comment" spellcheck="true">#1.基于docker-compose.yml启动管理的容器</span>docker<span class="token operator">-</span>compose up <span class="token operator">-</span>d<span class="token comment" spellcheck="true">#2.关闭并删除容器</span>docker<span class="token operator">-</span>compose down<span class="token comment" spellcheck="true">#3.开启|关闭|重启已经存在的由docker-compose维护的容器</span>docker<span class="token operator">-</span>compose <span class="token function">start</span><span class="token punctuation">|</span>stop<span class="token punctuation">|</span>restart<span class="token comment" spellcheck="true">#4.查看由docker-compose管理的容器</span>docker<span class="token operator">-</span>compose <span class="token function">ps</span><span class="token comment" spellcheck="true">#5.查看日志</span>docker<span class="token operator">-</span>compose logs <span class="token operator">-</span>f</code></pre><h3 id="4-docker-compose配合Dockerfile使用"><a href="#4-docker-compose配合Dockerfile使用" class="headerlink" title="4.docker-compose配合Dockerfile使用"></a>4.docker-compose配合Dockerfile使用</h3><blockquote><p>使用docker-compose.yml文件以及Dockerfile文件在生成自定义镜像的同时启动当前镜像，并且由docker-compose去管理容器</p></blockquote><h4 id="4-1docker-compose文件"><a href="#4-1docker-compose文件" class="headerlink" title="4.1docker-compose文件"></a>4.1docker-compose文件</h4><pre class=" language-powershell"><code class="language-powershell">编写docker<span class="token operator">-</span>compose文件<span class="token comment" spellcheck="true"># yml文件</span>version: <span class="token string">'3.1'</span>services:  ssm:    restart: always    build:            <span class="token comment" spellcheck="true"># 构建自定义镜像</span>      context: <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>      <span class="token comment" spellcheck="true"># 指定dockerfile文件的所在路径</span>      dockerfile: Dockerfile   <span class="token comment" spellcheck="true"># 指定Dockerfile文件名称</span>    image: ssm:1<span class="token punctuation">.</span>0<span class="token punctuation">.</span>1    container_name: ssm    ports:      <span class="token operator">-</span> 8081:8080    environment:      TZ: Asia<span class="token operator">/</span>Shanghai</code></pre><h4 id="4-2-Dockerfile文件"><a href="#4-2-Dockerfile文件" class="headerlink" title="4.2 Dockerfile文件"></a>4.2 Dockerfile文件</h4><pre class=" language-powershell"><code class="language-powershell">编写Dockerfile文件<span class="token keyword">from</span> daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span>library<span class="token operator">/</span>tomcat:8<span class="token punctuation">.</span>5<span class="token punctuation">.</span>15<span class="token operator">-</span>jre8<span class="token function">copy</span> ssm<span class="token punctuation">.</span>war <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>tomcat<span class="token operator">/</span>webapps</code></pre><h4 id="4-3-运行"><a href="#4-3-运行" class="headerlink" title="4.3 运行"></a>4.3 运行</h4><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#可以直接基于docker-compose.yml以及Dockerfile文件构建的自定义镜像</span>docker<span class="token operator">-</span>compose up <span class="token operator">-</span>d<span class="token comment" spellcheck="true"># 如果自定义镜像不存在，会帮助我们构建出自定义镜像，如果自定义镜像已经存在，会直接运行这个自定义镜像</span><span class="token comment" spellcheck="true">#重新构建自定义镜像</span>docker<span class="token operator">-</span>compose build<span class="token comment" spellcheck="true">#运行当前内容，并重新构建</span>docker<span class="token operator">-</span>compose up <span class="token operator">-</span>d <span class="token operator">--</span>build</code></pre><h2 id="九、CI、CD介绍及准备"><a href="#九、CI、CD介绍及准备" class="headerlink" title="九、CI、CD介绍及准备"></a>九、CI、CD介绍及准备</h2><h3 id="1-CI、CD引言"><a href="#1-CI、CD引言" class="headerlink" title="1.CI、CD引言"></a>1.CI、CD引言</h3><blockquote><p>项目部署<br>1.将项目通过maven进行编译打包<br>2.将文件上传到指定的服务器中<br>3.将war包放到tomcat的目录中<br>4.通过Dockerfile将Tomcat和war包转成一个镜像，由DockerCompose去运行容器 项目更新后，需要将上述流程再次的从头到尾的执行一次，如果每次更新一次都执行一次上述操作，很费时，费力。我们就可以通过CI、CD帮助我们实现持续集成，持续交付和部署</p></blockquote><h3 id="2-CI介绍"><a href="#2-CI介绍" class="headerlink" title="2.CI介绍"></a>2.CI介绍</h3><blockquote><p>CI（continuous intergration）持续集成<br>持续集成：编写代码时，完成了一个功能后，立即提交代码到Git仓库中，将项目重新的构建并且测试。<br>1.快速发现错误。<br>2.防止代码偏离主分支。</p></blockquote><h3 id="3-搭建Gitlab服务器"><a href="#3-搭建Gitlab服务器" class="headerlink" title="3.搭建Gitlab服务器"></a>3.搭建Gitlab服务器</h3><h4 id="3-1-准备环境"><a href="#3-1-准备环境" class="headerlink" title="3.1.准备环境"></a>3.1.准备环境</h4><p>实现CI，需要使用到Gitlab远程仓库，先通过Docker搭建Gitlab</p><blockquote><p>创建一个全新的虚拟机，并且至少指定4G的运行内存，4G运行内存是Gitlab推荐的内存大小。<br>并且安装Docker以及Docker-Compose</p></blockquote><h4 id="3-2-修改ssh的22端口"><a href="#3-2-修改ssh的22端口" class="headerlink" title="3.2 修改ssh的22端口"></a>3.2 修改ssh的22端口</h4><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#将ssh的默认22端口，修改为60022端口，因为Gitlab需要占用22端口</span>vi <span class="token operator">/</span>etc<span class="token operator">/</span>ssh<span class="token operator">/</span>sshd_config  PORT 22 <span class="token operator">-</span>> 60022systemctl restart sshd</code></pre><h4 id="3-3-编写docker-compose-yml"><a href="#3-3-编写docker-compose-yml" class="headerlink" title="3.3 编写docker-compose.yml"></a>3.3 编写docker-compose.yml</h4><pre class=" language-powershell"><code class="language-powershell">docker<span class="token operator">-</span>compose<span class="token punctuation">.</span>yml文件去安装gitlab（下载和运行的时间比较长的）version: <span class="token string">'3.1'</span>services: gitlab:  image: <span class="token string">'twang2218/gitlab-ce-zh:11.1.4'</span>  container_name: <span class="token string">"gitlab"</span>  restart: always  privileged: true  hostname: <span class="token string">'gitlab'</span>  environment:   TZ: <span class="token string">'Asia/Shanghai'</span>   GITLAB_OMNIBUS_CONFIG: <span class="token punctuation">|</span>    external_url <span class="token string">'http://192.168.199.110'</span>    gitlab_rails<span class="token punctuation">[</span><span class="token string">'time_zone'</span><span class="token punctuation">]</span> = <span class="token string">'Asia/Shanghai'</span>    gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_enable'</span><span class="token punctuation">]</span> = true    gitlab_rails<span class="token punctuation">[</span><span class="token string">'gitlab_shell_ssh_port'</span><span class="token punctuation">]</span> = 22  ports:   <span class="token operator">-</span> <span class="token string">'80:80'</span>   <span class="token operator">-</span> <span class="token string">'443:443'</span>   <span class="token operator">-</span> <span class="token string">'22:22'</span>  volumes:   <span class="token operator">-</span> <span class="token operator">/</span>opt<span class="token operator">/</span>docker_gitlab<span class="token operator">/</span>config:<span class="token operator">/</span>etc<span class="token operator">/</span>gitlab   <span class="token operator">-</span> <span class="token operator">/</span>opt<span class="token operator">/</span>docker_gitlab<span class="token operator">/</span><span class="token keyword">data</span>:<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>opt<span class="token operator">/</span>gitlab   <span class="token operator">-</span> <span class="token operator">/</span>opt<span class="token operator">/</span>docker_gitlab<span class="token operator">/</span>logs:<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>log<span class="token operator">/</span>gitlab</code></pre><h2 id="十、搭建GitlabRunner"><a href="#十、搭建GitlabRunner" class="headerlink" title="十、搭建GitlabRunner"></a>十、搭建GitlabRunner</h2><h3 id="1-准备文件"><a href="#1-准备文件" class="headerlink" title="1.准备文件"></a>1.准备文件</h3><pre class=" language-powershell"><code class="language-powershell">daemon<span class="token punctuation">.</span>json&amp;<span class="token comment" spellcheck="true">#123;</span>“registry<span class="token operator">-</span>mirrors”: <span class="token punctuation">[</span>“https:<span class="token operator">/</span><span class="token operator">/</span>registry<span class="token punctuation">.</span>docker<span class="token operator">-</span>cn<span class="token punctuation">.</span>com”<span class="token punctuation">]</span><span class="token punctuation">,</span>“insecure<span class="token operator">-</span>registries”: <span class="token namespace">[ip:ports]</span>&amp;<span class="token comment" spellcheck="true">#125;</span>文件夹 environment里面准备maven安装包，jdk1<span class="token punctuation">.</span>8安装包，Dockerfile，daemon<span class="token punctuation">.</span>json以及docker<span class="token operator">-</span>compose</code></pre><h3 id="2-开始搭建"><a href="#2-开始搭建" class="headerlink" title="2.开始搭建"></a>2.开始搭建</h3><blockquote><p>创建工作目录 /usr/local/docker_gitlab-runner<br>将docker-compose.yml文件以及environment目录全部复制到上述目录中 在宿主机启动docker程序后先执行 sudo<br>chown root:root /var/run/docker.sock (如果重启过 docker,重新执行)<br>在/usr/local/docker_gitlab-runner 目录中执行docker-compose up -d –build 启动容器<br>添加容器权限，保证容器可以使用宿主机的dockerdocker exec -it gitlab-runner usermod -aG<br>root gitlab-runner 注册Runner信息到gitlab</p></blockquote><h3 id="3-进入后续步骤"><a href="#3-进入后续步骤" class="headerlink" title="3.进入后续步骤"></a>3.进入后续步骤</h3><pre class=" language-powershell"><code class="language-powershell">docker exec <span class="token operator">-</span>it gitlab<span class="token operator">-</span>runner gitlab<span class="token operator">-</span>runner register<span class="token comment" spellcheck="true"># 输入 GitLab 地址</span>Please enter the gitlab<span class="token operator">-</span>ci coordinator URL <span class="token punctuation">(</span>e<span class="token punctuation">.</span>g<span class="token punctuation">.</span> https:<span class="token operator">/</span><span class="token operator">/</span>gitlab<span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token punctuation">)</span>:http:<span class="token operator">/</span><span class="token operator">/</span>192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>199<span class="token punctuation">.</span>109<span class="token operator">/</span><span class="token comment" spellcheck="true"># 输入 GitLab Token</span>Please enter the gitlab<span class="token operator">-</span>ci token <span class="token keyword">for</span> this runner:1Lxq_f1NRfCfeNbE5WRh<span class="token comment" spellcheck="true"># 输入 Runner 的说明</span>Please enter the gitlab<span class="token operator">-</span>ci description <span class="token keyword">for</span> this runner:可以为空<span class="token comment" spellcheck="true"># 设置 Tag，可以用于指定在构建规定的 tag 时触发 ci</span>Please enter the gitlab<span class="token operator">-</span>ci tags <span class="token keyword">for</span> this runner <span class="token punctuation">(</span>comma separated<span class="token punctuation">)</span>:deploy<span class="token comment" spellcheck="true"># 这里选择 true ，可以用于代码上传后直接执行（根据版本，也会没有次选项）</span>Whether to run untagged builds <span class="token namespace">[true/false]</span>:true<span class="token comment" spellcheck="true"># 这里选择 false，可以直接回车，默认为 false（根据版本，也会没有次选项）</span>Whether to lock Runner to current project <span class="token namespace">[true/false]</span>:false<span class="token comment" spellcheck="true"># 选择 runner 执行器，这里我们选择的是 shell</span>Please enter the executor: virtualbox<span class="token punctuation">,</span> docker<span class="token operator">+</span>machine<span class="token punctuation">,</span> parallels<span class="token punctuation">,</span> shell<span class="token punctuation">,</span> ssh<span class="token punctuation">,</span> docker<span class="token operator">-</span>ssh<span class="token operator">+</span>machine<span class="token punctuation">,</span> kubernetes<span class="token punctuation">,</span> docker<span class="token punctuation">,</span> docker<span class="token operator">-</span>ssh:shell</code></pre><h2 id="十一、整合项目入门测试"><a href="#十一、整合项目入门测试" class="headerlink" title="十一、整合项目入门测试"></a>十一、整合项目入门测试</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h3><blockquote><p>创建maven工程，添加web.xml文件，编写HTML页面</p></blockquote><h3 id="2-编写-gitlab-ci-yml文件"><a href="#2-编写-gitlab-ci-yml文件" class="headerlink" title="2.编写.gitlab-ci.yml文件"></a>2.编写.gitlab-ci.yml文件</h3><pre class=" language-powershell"><code class="language-powershell">stages:  <span class="token operator">-</span> testtest:  stage: test  script:    <span class="token operator">-</span> <span class="token function">echo</span> first test ci   <span class="token comment" spellcheck="true"># 输入的命令</span></code></pre><h3 id="3-将maven工程推送到gitlab中"><a href="#3-将maven工程推送到gitlab中" class="headerlink" title="3.将maven工程推送到gitlab中"></a>3.将maven工程推送到gitlab中</h3><pre class=" language-powershell"><code class="language-powershell">执行git命令推送到Gitlabgit push origin master</code></pre><h3 id="4-查看效果"><a href="#4-查看效果" class="headerlink" title="4.查看效果"></a>4.查看效果</h3><blockquote><p>可以在gitlab中查看到gitlab-ci.yml编写的内容</p></blockquote><h2 id="十二、完善项目配置"><a href="#十二、完善项目配置" class="headerlink" title="十二、完善项目配置"></a>十二、完善项目配置</h2><blockquote><p>添加Dockerfile以及docker-compose.yml， 并修改.gitlab-ci.yml文件</p></blockquote><h3 id="1-创建Dockerfile"><a href="#1-创建Dockerfile" class="headerlink" title="1.创建Dockerfile"></a>1.创建Dockerfile</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># Dockerfile</span><span class="token keyword">FROM</span> daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span>library<span class="token operator">/</span>tomcat:8<span class="token punctuation">.</span>5<span class="token punctuation">.</span>15<span class="token operator">-</span>jre8<span class="token function">COPY</span> testci<span class="token punctuation">.</span>war <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>tomcat<span class="token operator">/</span>webapps</code></pre><h3 id="2-创建docker-compose-yml"><a href="#2-创建docker-compose-yml" class="headerlink" title="2.创建docker-compose.yml"></a>2.创建docker-compose.yml</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># docker-compose.yml</span>version: <span class="token string">"3.1"</span>services:  testci:    build: docker    restart: always    container_name: testci    ports:      <span class="token operator">-</span> 8080:8080</code></pre><h3 id="3-修改-gitlab-ci-yml"><a href="#3-修改-gitlab-ci-yml" class="headerlink" title="3.修改.gitlab-ci.yml"></a>3.修改.gitlab-ci.yml</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># ci.yml</span>stages:  <span class="token operator">-</span> testtest:  stage: test  script:    <span class="token operator">-</span> <span class="token function">echo</span> first test ci    <span class="token operator">-</span> <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>maven<span class="token operator">/</span>apache<span class="token operator">-</span>maven<span class="token operator">-</span>3<span class="token punctuation">.</span>6<span class="token punctuation">.</span>3<span class="token operator">/</span>bin<span class="token operator">/</span>mvn package    <span class="token operator">-</span> <span class="token function">cp</span> target<span class="token operator">/</span>testci<span class="token operator">-</span>1<span class="token punctuation">.</span>0<span class="token operator">-</span>SNAPSHOT<span class="token punctuation">.</span>war docker<span class="token operator">/</span>testci<span class="token punctuation">.</span>war    <span class="token operator">-</span> docker<span class="token operator">-</span>compose down    <span class="token operator">-</span> docker<span class="token operator">-</span>compose up <span class="token operator">-</span>d <span class="token operator">--</span>build    <span class="token operator">-</span> docker rmi $<span class="token punctuation">(</span>docker images <span class="token operator">-</span>qf dangling=true<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux运维教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/3eeb.html"/>
      <url>/post/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>hexo clean</p><p>hexo g</p><p>hexo d</p><p>hexo s</p>]]></content>
      
      
      <categories>
          
          <category> Hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> INIT </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
