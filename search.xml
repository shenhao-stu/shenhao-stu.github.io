<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Picgo图床配置</title>
      <link href="/post/bfd4.html"/>
      <url>/post/bfd4.html</url>
      
        <content type="html"><![CDATA[<h1 id="PicGo图床配置教程"><a href="#PicGo图床配置教程" class="headerlink" title="PicGo图床配置教程"></a>PicGo图床配置教程</h1><h2 id="一、什么是图床"><a href="#一、什么是图床" class="headerlink" title="一、什么是图床"></a>一、什么是图床</h2><p>图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。 </p><p>简单来说就是：在文章中引用指定网址显示图片。 </p><p><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/1.png"></p><p><font color="red">平常我们都是在网络上复制粘贴网络图片的地址，太out了，如何快速引用本地图片呢？？</font></p><h2 id="二、配置教程"><a href="#二、配置教程" class="headerlink" title="二、配置教程"></a>二、配置教程</h2><h3 id="1-获取Token"><a href="#1-获取Token" class="headerlink" title="1.获取Token"></a>1.获取Token</h3><blockquote><p> github云端仓库位置： 延续上一次cdn的仓库失败。（建议新建一个仓库，发布过release版本号的仓库会使用异常）</p></blockquote><p>1.进入设置Setting<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/3.png"><br>2.选择开发者设置Developer setting<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/2.png"><br>3.选择个人数据帧Personal access tokens，生成新的数据帧 Generate new token<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/4.png"><br>4.命名为picgo（图床），赋予仓库权限<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/5.png"><br>5.最后点击Generate token即可看到显示的token页面，<strong>它只会显示一次，关闭页面后再打开这个页面就不会显示了。</strong> 复制token值粘贴到文本文档中，先保存下来，后面配置PicGo要用到。<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/6.png"></p><h3 id="2-本地安装图片上传工具"><a href="#2-本地安装图片上传工具" class="headerlink" title="2.本地安装图片上传工具"></a>2.本地安装图片上传工具</h3><ol><li><p>首先下载PicGo，图片上传工具PicGo下载址:<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p></li><li><p>安装配置PicGo<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/7.png"></p></li></ol><ul><li>设定仓库名：这个是刚刚第一步所新建仓库的名称，我的为cdn，此处填写格式username/repo。 </li><li>设定分支名：master，采用默认分支即可 </li><li>设定Token：此处填写上一步得到的Token，添加到输入框即可。</li><li>指定存储路径：自定义，例：images/，相当于在刚刚新建的仓库下新建了一个文件夹。 </li><li>设定自定义域名：cdn加速格式：<a href="https://cdn.jsdelivr.net/gh/username/repo">https://cdn.jsdelivr.net/gh/username/repo</a></li><li>username为GitHub用户名，repo为新建的仓库，用于存储图片 </li></ul><h2 id="三、上传方法"><a href="#三、上传方法" class="headerlink" title="三、上传方法"></a>三、上传方法</h2><ol><li><p>快捷键上传 </p></li><li><p>拖拽上传<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/8.png"><br>上传后，云端图片显示：<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/9.png"></p></li><li><p>使用方法：选择<strong>相册</strong>，可<strong>复制、修改链接、删除</strong>图片（不能删除github上的图片，需要手动删除）：<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/11.png"> </p></li></ol><h2 id="四、解决无法上传的问题"><a href="#四、解决无法上传的问题" class="headerlink" title="四、解决无法上传的问题"></a>四、解决无法上传的问题</h2><p>进入PicGo设置，找到设置Server，并选择关闭<br><img src="https://cdn.jsdelivr.net/gh/shenhao-stu/picgo/images/10.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo个性化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Picgo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-2020详细教程</title>
      <link href="/post/3254.html"/>
      <url>/post/3254.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-2020详细教程-lt-配合千锋Java学习营-gt"><a href="#Docker-2020详细教程-lt-配合千锋Java学习营-gt" class="headerlink" title="Docker-2020详细教程<配合千锋Java学习营>"></a>Docker-2020详细教程&lt;配合千锋Java学习营&gt;</h1><h2 id="一、Docker介绍"><a href="#一、Docker介绍" class="headerlink" title="一、Docker介绍"></a>一、Docker介绍</h2><h3 id="1-下载Dcoker依的赖环境"><a href="#1-下载Dcoker依的赖环境" class="headerlink" title="1.下载Dcoker依的赖环境"></a>1.下载Dcoker依的赖环境</h3><pre class=" language-bash"><code class="language-bash">想安装Docker，需要先将依赖的环境全部下载下来，就像Maven依赖JDK一样yum -y <span class="token function">install</span> yum-utils device-mapper-persistent-data lvm2</code></pre><h3 id="2-指定Docker镜像源"><a href="#2-指定Docker镜像源" class="headerlink" title="2.指定Docker镜像源"></a>2.指定Docker镜像源</h3><pre class=" language-powershell"><code class="language-powershell">默认下载Docker会去国外服务器下载，速度较慢，可以设置为阿里云镜像源，速度更快yum<span class="token operator">-</span>config<span class="token operator">-</span>manager <span class="token operator">--</span>add<span class="token operator">-</span>repo http:<span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>docker<span class="token operator">-</span>ce<span class="token operator">/</span>linux<span class="token operator">/</span>centos<span class="token operator">/</span>docker<span class="token operator">-</span>ce<span class="token punctuation">.</span>repo</code></pre><h3 id="3-安装Docker"><a href="#3-安装Docker" class="headerlink" title="3.安装Docker"></a>3.安装Docker</h3><pre class=" language-powershell"><code class="language-powershell">yum makecache fastyum <span class="token operator">-</span>y install docker<span class="token operator">-</span>ce</code></pre><h3 id="4-启动Docker并测试"><a href="#4-启动Docker并测试" class="headerlink" title="4.启动Docker并测试"></a>4.启动Docker并测试</h3><pre class=" language-powershell"><code class="language-powershell">安装成功后，需要手动启动，设置为开机启动，并测试一下 Docker<span class="token comment" spellcheck="true">#启动docker服务</span>systemctl <span class="token function">start</span> docker<span class="token comment" spellcheck="true">#设置开机自动启动</span>systemctl enable docker<span class="token comment" spellcheck="true">#测试</span>docker run hello<span class="token operator">-</span>world</code></pre><h2 id="二、Docker的中央仓库"><a href="#二、Docker的中央仓库" class="headerlink" title="二、Docker的中央仓库"></a>二、Docker的中央仓库</h2><pre class=" language-powershell"><code class="language-powershell">1<span class="token punctuation">.</span>Docker官方的中央仓库：这个仓库是镜像最全的，但是下载速度较慢。https:<span class="token operator">/</span><span class="token operator">/</span>hub<span class="token punctuation">.</span>docker<span class="token punctuation">.</span>com<span class="token operator">/</span>2<span class="token punctuation">.</span>国内的镜像网站：网易蜂巢，daoCloud等，下载速度快，但是镜像相对不全。https:<span class="token operator">/</span><span class="token operator">/</span>c<span class="token punctuation">.</span>163yun<span class="token punctuation">.</span>com<span class="token operator">/</span>hub<span class="token comment" spellcheck="true">#/home </span>http:<span class="token operator">/</span><span class="token operator">/</span>hub<span class="token punctuation">.</span>daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span> （推荐使用）3<span class="token punctuation">.</span>在公司内部会采用私服的方式拉取镜像（添加配置）<span class="token comment" spellcheck="true">#需要创建 /etc/docker/daemon.json，并添加如下内容</span><span class="token punctuation">{</span>    <span class="token string">"registry-mirrors"</span>:<span class="token punctuation">[</span><span class="token string">"https://registry.docker-cn.com"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token string">"insecure-registries"</span>:<span class="token punctuation">[</span><span class="token string">"ip:port"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#重启两个服务</span>systemctl daemon<span class="token operator">-</span>reloadsystemctl restart docker</code></pre><h2 id="三、镜像的操作"><a href="#三、镜像的操作" class="headerlink" title="三、镜像的操作"></a>三、镜像的操作</h2><h3 id="1-拉取镜像"><a href="#1-拉取镜像" class="headerlink" title="1.拉取镜像"></a>1.拉取镜像</h3><pre class=" language-powershell"><code class="language-powershell">从中央仓库拉取镜像到本地docker pull 镜像名称<span class="token punctuation">[</span>:tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#举个栗子:docker pull daocloud.io/library/tomcat:8.5.15-jre8</span></code></pre><h3 id="2-查看本地全部镜像"><a href="#2-查看本地全部镜像" class="headerlink" title="2.查看本地全部镜像"></a>2.查看本地全部镜像</h3><pre class=" language-powershell"><code class="language-powershell">查看本地已经安装过的镜像信息，包含标识，名称，版本，更新时间，大小docker images</code></pre><h3 id="3-删除本地镜像"><a href="#3-删除本地镜像" class="headerlink" title="3.删除本地镜像"></a>3.删除本地镜像</h3><pre class=" language-powershell"><code class="language-powershell">镜像会占用磁盘空间，可以直接手动删除，标识通过查看获取docker rmi 镜像的标识</code></pre><h3 id="4-镜像的导入导出"><a href="#4-镜像的导入导出" class="headerlink" title="4.镜像的导入导出"></a>4.镜像的导入导出</h3><pre class=" language-powershell"><code class="language-powershell">如果因为网络原因可以通过硬盘的方式传输镜像，虽然不规范，但是有效，但是这种方式导出的镜像名称和版本都是null，需要手动修改<span class="token comment" spellcheck="true">#将本地的镜像导出</span>docker save <span class="token operator">-</span>o 导出的路径 镜像id<span class="token comment" spellcheck="true">#加载本地的镜像文件</span>docker load <span class="token operator">-</span>i 镜像文件<span class="token comment" spellcheck="true">#修改镜像文件</span>docker tag 镜像id 新镜像名称：版本</code></pre><h2 id="四、容器的操作"><a href="#四、容器的操作" class="headerlink" title="四、容器的操作"></a>四、容器的操作</h2><h3 id="1-运行容器"><a href="#1-运行容器" class="headerlink" title="1.运行容器"></a>1.运行容器</h3><pre class=" language-powershell"><code class="language-powershell">运行容器需要定制具体镜像，如果镜像不存在，会直接下载<span class="token comment" spellcheck="true">#简单操作</span>docker run 镜像的标识<span class="token punctuation">|</span>镜像的名称<span class="token punctuation">[</span>:tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#常用的参数</span>docker run <span class="token operator">-</span>d <span class="token operator">-</span>p 宿主机端口:容器端口 <span class="token operator">--</span>name 容器名称 镜像的标识<span class="token punctuation">|</span>镜像名称<span class="token punctuation">[</span>:tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#-d:代表后台运行容器</span><span class="token comment" spellcheck="true">#-p 宿主机端口:容器端口：为了映射当前Linux的端口和容器的端口</span><span class="token comment" spellcheck="true">#--name 容器名称:指定容器的名称</span></code></pre><h3 id="2-查看正在运行的容器"><a href="#2-查看正在运行的容器" class="headerlink" title="2.查看正在运行的容器"></a>2.查看正在运行的容器</h3><pre class=" language-powershell"><code class="language-powershell">查看全部正在运行的容器信息docker <span class="token function">ps</span> <span class="token punctuation">[</span><span class="token operator">-</span>qa<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#-a 查看全部的容器，包括没有运行</span><span class="token comment" spellcheck="true">#-q 只查看容器的标识</span></code></pre><h3 id="3-查看容器日志"><a href="#3-查看容器日志" class="headerlink" title="3.查看容器日志"></a>3.查看容器日志</h3><pre class=" language-powershell"><code class="language-powershell">查看容器日志，以查看容器运行的信息docker logs <span class="token operator">-</span>f 容器id<span class="token comment" spellcheck="true">#-f：可以滚动查看日志的最后几行</span></code></pre><h3 id="4-进入容器的内部"><a href="#4-进入容器的内部" class="headerlink" title="4.进入容器的内部"></a>4.进入容器的内部</h3><pre class=" language-powershell"><code class="language-powershell">可以进入容器的内部进行操作docker exec <span class="token operator">-</span>it 容器id bash</code></pre><h3 id="5-复制内容到容器"><a href="#5-复制内容到容器" class="headerlink" title="5.复制内容到容器"></a>5.复制内容到容器</h3><pre class=" language-powershell"><code class="language-powershell">将宿主机的文件复制到容器内部的指定目录docker <span class="token function">cp</span> 文件名称 容器id:容器内部路径</code></pre><h3 id="6-重启-amp-启动-amp-停止-amp-删除容器"><a href="#6-重启-amp-启动-amp-停止-amp-删除容器" class="headerlink" title="6.重启&amp;启动&amp;停止&amp;删除容器"></a>6.重启&amp;启动&amp;停止&amp;删除容器</h3><pre class=" language-powershell"><code class="language-powershell">容器的启动，停止，删除等操作，后续会经常使用到<span class="token comment" spellcheck="true">#重新启动容器</span>docker restart 容器id<span class="token comment" spellcheck="true">#启动停止运行的容器</span>docker <span class="token function">start</span> 容器id<span class="token comment" spellcheck="true">#停止指定的容器(删除容器前，需要先停止容器)</span>docker stop 容器id<span class="token comment" spellcheck="true">#停止全部容器</span>docker stop $<span class="token punctuation">(</span>docker <span class="token function">ps</span> <span class="token operator">-</span>qa<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#删除指定容器</span>docker <span class="token function">rm</span> 容器id<span class="token comment" spellcheck="true">#删除全部容器</span>docker <span class="token function">rm</span> $<span class="token punctuation">(</span>docker <span class="token function">ps</span> <span class="token operator">-</span>qa<span class="token punctuation">)</span></code></pre><h2 id="五、Docker应用"><a href="#五、Docker应用" class="headerlink" title="五、Docker应用"></a>五、Docker应用</h2><h3 id="1-docker安装tomcat"><a href="#1-docker安装tomcat" class="headerlink" title="1.docker安装tomcat"></a>1.docker安装tomcat</h3><pre class=" language-powershell"><code class="language-powershell">运行Tomcat容器，为部署ssm工程做准备docker run <span class="token operator">-</span>d <span class="token operator">-</span>p 8080:8080 <span class="token operator">--</span>name tomcat  daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span>library<span class="token operator">/</span>tomcat:8<span class="token punctuation">.</span>5<span class="token punctuation">.</span>15<span class="token operator">-</span>jre8<span class="token comment" spellcheck="true">#或者已经下载了tomcat镜像</span>docker run <span class="token operator">-</span>d <span class="token operator">-</span>p 8080:8080 <span class="token operator">--</span>name tomcat 镜像的标识</code></pre><h3 id="2-运行MySQL容器"><a href="#2-运行MySQL容器" class="headerlink" title="2.运行MySQL容器"></a>2.运行MySQL容器</h3><pre class=" language-powershell"><code class="language-powershell">docker run <span class="token operator">-</span>d <span class="token operator">-</span>p 3306:3306 <span class="token operator">--</span>name mysql <span class="token operator">-</span>e MYSQL_ROOT_PASSWORD=root daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span>library<span class="token operator">/</span>mysql:5<span class="token punctuation">.</span>7<span class="token punctuation">.</span>4</code></pre><h3 id="3-部署ssm工程"><a href="#3-部署ssm工程" class="headerlink" title="3.部署ssm工程"></a>3.部署ssm工程</h3><pre class=" language-powershell"><code class="language-powershell">修改SSM工程环境，设置为Linux中Docker容器的信息通过Maven的package重新打成war包将Windows下的war包复制到Linux中通过docker命令将宿主机的war包复制到容器内部docker <span class="token function">cp</span> 文件名称 容器id:容器内部路径测试访问SSM工程</code></pre><h2 id="六、数据卷"><a href="#六、数据卷" class="headerlink" title="六、数据卷"></a>六、数据卷</h2><blockquote><p>为了部署SSM的工程，需要使用到cp的命令将宿主机内的ssm.war文件复制到容器内部。 数据卷：将宿主机的一个目录映射到容器的一个目录中。</p><p>可以在宿主机中操作目录中的内容，那么容器内部映射的文件，也会跟着一起改变。</p></blockquote><h3 id="1-创建数据卷"><a href="#1-创建数据卷" class="headerlink" title="1.创建数据卷"></a>1.创建数据卷</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#创建数据卷后，默认会存放在一个目录下/var/lib/docker/volumes/数据卷名称/_data</span>docker volume create 数据卷名称</code></pre><h3 id="2-查看全部数据卷"><a href="#2-查看全部数据卷" class="headerlink" title="2.查看全部数据卷"></a>2.查看全部数据卷</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#查看全部数据卷信息</span>docker volume <span class="token function">ls</span></code></pre><h3 id="3-查看数据卷详情"><a href="#3-查看数据卷详情" class="headerlink" title="3.查看数据卷详情"></a>3.查看数据卷详情</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#查看数据卷的详细信息，可以查询到存放的路径，创建时间等等</span>docker volume inspect 数据卷名称</code></pre><h3 id="4-删除数据卷"><a href="#4-删除数据卷" class="headerlink" title="4.删除数据卷"></a>4.删除数据卷</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#删除指定的数据卷</span>docker volume <span class="token function">rm</span> 数据卷名称</code></pre><h3 id="5-容器映射数据卷"><a href="#5-容器映射数据卷" class="headerlink" title="5.容器映射数据卷"></a>5.容器映射数据卷</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#通过数据卷名称映射，如果数据卷不存在。Docker会帮你自动创建，会将容器内部自带的文件，存储在默认的存放路径中。</span>docker run <span class="token operator">-</span>d <span class="token operator">-</span>p 8080:8080 <span class="token operator">--</span>name tomcat <span class="token operator">-</span>v 数据卷名称:容器内部的路径 镜像id<span class="token comment" spellcheck="true">#通过路径映射数据卷，直接指定一个路径作为数据卷的存放位置。但是这个路径下是空的。</span>docker run <span class="token operator">-</span>d <span class="token operator">-</span>p 8080:8080 <span class="token operator">--</span>name tomcat <span class="token operator">-</span>v 路径<span class="token punctuation">(</span><span class="token operator">/</span>root<span class="token operator">/</span>自己创建的文件夹<span class="token punctuation">)</span>:容器内部的路径 镜像id</code></pre><h2 id="七、Dockerfile自定义镜像"><a href="#七、Dockerfile自定义镜像" class="headerlink" title="七、Dockerfile自定义镜像"></a>七、Dockerfile自定义镜像</h2><h3 id="1-Dockerfile"><a href="#1-Dockerfile" class="headerlink" title="1.Dockerfile"></a>1.Dockerfile</h3><pre class=" language-powershell"><code class="language-powershell">创建自定义镜像就需要创建一个Dockerfiler<span class="token punctuation">,</span>如下为Dockerfile的语言<span class="token keyword">from</span>：指定当前自定义镜像依赖的环境<span class="token function">copy</span>：将相对路径下的内容复制到自定义镜像中workdir：声明镜像的默认工作目录run：执行的命令，可以编写多个cmd：需要执行的命令（在workdir下执行的，cmd可以写多个，只以最后一个为准）<span class="token comment" spellcheck="true">#示例：</span><span class="token keyword">from</span> daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span>library<span class="token operator">/</span>tomcat:8<span class="token punctuation">.</span>5<span class="token punctuation">.</span>15<span class="token operator">-</span>jre8<span class="token function">copy</span> ssm<span class="token punctuation">.</span>war <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>tomcat<span class="token operator">/</span>webapps</code></pre><h2 id="2-通过Dockerfile制作镜像"><a href="#2-通过Dockerfile制作镜像" class="headerlink" title="2.通过Dockerfile制作镜像"></a>2.通过Dockerfile制作镜像</h2><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#编写完Dockerfile后需要通过命令将其制作为镜像，并且要在Dockerfile的当前目录下，之后即可在镜像中查看到指定的镜像信息，注意最后的 .</span>docker build <span class="token operator">-</span>t 镜像名称<span class="token punctuation">[</span>:tag<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token operator">/</span></code></pre><h2 id="八、Docker-Compose"><a href="#八、Docker-Compose" class="headerlink" title="八、Docker-Compose"></a>八、Docker-Compose</h2><h3 id="1-下载并安装Docker-Compose"><a href="#1-下载并安装Docker-Compose" class="headerlink" title="1.下载并安装Docker-Compose"></a>1.下载并安装Docker-Compose</h3><h4 id="1-1下载Docker-Compose"><a href="#1-1下载Docker-Compose" class="headerlink" title="1.1下载Docker-Compose"></a>1.1下载Docker-Compose</h4><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#去github官网搜索docker-compose，下载1.24.1版本的Docker-Compose</span>下载路径：https:<span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>docker<span class="token operator">/</span>compose<span class="token operator">/</span>releases<span class="token operator">/</span>download<span class="token operator">/</span>1<span class="token punctuation">.</span>24<span class="token punctuation">.</span>1<span class="token operator">/</span>docker<span class="token operator">-</span>compose<span class="token operator">-</span>Linux<span class="token operator">-</span>x86_64</code></pre><h4 id="1-2设置权限"><a href="#1-2设置权限" class="headerlink" title="1.2设置权限"></a>1.2设置权限</h4><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#需要将DockerCompose文件的名称修改一下，给予DockerCompose文件一个可执行的权限</span><span class="token function">mv</span> docker<span class="token operator">-</span>compose<span class="token operator">-</span>Linux<span class="token operator">-</span>x86_64 docker<span class="token operator">-</span>composechmod 777 docker<span class="token operator">-</span>compose</code></pre><h4 id="1-3配置环境变量"><a href="#1-3配置环境变量" class="headerlink" title="1.3配置环境变量"></a>1.3配置环境变量</h4><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#方便后期操作，配置一个环境变量</span><span class="token comment" spellcheck="true">#将docker-compose文件移动到了/usr/local/bin，修改了/etc/profile文件，给/usr/local/bin配置到了PATH中</span><span class="token function">mv</span> docker<span class="token operator">-</span>compose <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>binvi <span class="token operator">/</span>etc<span class="token operator">/</span>profile<span class="token comment" spellcheck="true">#添加内容：export PATH=$JAVA_HOME:/usr/local/bin:$PATH</span>source <span class="token operator">/</span>etc<span class="token operator">/</span>profile</code></pre><h4 id="1-4测试"><a href="#1-4测试" class="headerlink" title="1.4测试"></a>1.4测试</h4><pre class=" language-powershell"><code class="language-powershell">在任意目录下输入docker<span class="token operator">-</span>compose</code></pre><h3 id="2-Docker-Compose管理MySQL和Tomcat容器"><a href="#2-Docker-Compose管理MySQL和Tomcat容器" class="headerlink" title="2.Docker-Compose管理MySQL和Tomcat容器"></a>2.Docker-Compose管理MySQL和Tomcat容器</h3><pre class=" language-powershell"><code class="language-powershell">yml文件以key:value方式来指定配置信息多个配置信息以换行<span class="token operator">+</span>缩进的方式来区分在docker<span class="token operator">-</span>compose<span class="token punctuation">.</span>yml文件中，不要使用制表符version: <span class="token string">'3.1'</span>services:  mysql:           <span class="token comment" spellcheck="true"># 服务的名称</span>    restart: always   <span class="token comment" spellcheck="true"># 代表只要docker启动，那么这个容器就跟着一起启动</span>    image: daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span>library<span class="token operator">/</span>mysql:5<span class="token punctuation">.</span>7<span class="token punctuation">.</span>4  <span class="token comment" spellcheck="true"># 指定镜像路径</span>    container_name: mysql  <span class="token comment" spellcheck="true"># 指定容器名称</span>    ports:      <span class="token operator">-</span> 3306:3306   <span class="token comment" spellcheck="true">#  指定端口号的映射</span>    environment:      MYSQL_ROOT_PASSWORD: root   <span class="token comment" spellcheck="true"># 指定MySQL的ROOT用户登录密码</span>      TZ: Asia<span class="token operator">/</span>Shanghai        <span class="token comment" spellcheck="true"># 指定时区</span>    volumes:     <span class="token operator">-</span> <span class="token operator">/</span>opt<span class="token operator">/</span>docker_mysql_tomcat<span class="token operator">/</span>mysql_data:<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>mysql   <span class="token comment" spellcheck="true"># 映射数据卷</span>  tomcat:    restart: always    image: daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span>library<span class="token operator">/</span>tomcat:8<span class="token punctuation">.</span>5<span class="token punctuation">.</span>15<span class="token operator">-</span>jre8    container_name: tomcat    ports:      <span class="token operator">-</span> 8080:8080    environment:      TZ: Asia<span class="token operator">/</span>Shanghai    volumes:      <span class="token operator">-</span> <span class="token operator">/</span>opt<span class="token operator">/</span>docker_mysql_tomcat<span class="token operator">/</span>tomcat_webapps:<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>tomcat<span class="token operator">/</span>webapps      <span class="token operator">-</span> <span class="token operator">/</span>opt<span class="token operator">/</span>docker_mysql_tomcat<span class="token operator">/</span>tomcat_logs:<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>tomcat<span class="token operator">/</span>logs</code></pre><h3 id="3-使用docker-compose命令管理容器"><a href="#3-使用docker-compose命令管理容器" class="headerlink" title="3.使用docker-compose命令管理容器"></a>3.使用docker-compose命令管理容器</h3><pre class=" language-powershell"><code class="language-powershell">在使用docker<span class="token operator">-</span>compose的命令时，默认会在当前目录下找docker<span class="token operator">-</span>compose<span class="token punctuation">.</span>yml文件<span class="token comment" spellcheck="true">#1.基于docker-compose.yml启动管理的容器</span>docker<span class="token operator">-</span>compose up <span class="token operator">-</span>d<span class="token comment" spellcheck="true">#2.关闭并删除容器</span>docker<span class="token operator">-</span>compose down<span class="token comment" spellcheck="true">#3.开启|关闭|重启已经存在的由docker-compose维护的容器</span>docker<span class="token operator">-</span>compose <span class="token function">start</span><span class="token punctuation">|</span>stop<span class="token punctuation">|</span>restart<span class="token comment" spellcheck="true">#4.查看由docker-compose管理的容器</span>docker<span class="token operator">-</span>compose <span class="token function">ps</span><span class="token comment" spellcheck="true">#5.查看日志</span>docker<span class="token operator">-</span>compose logs <span class="token operator">-</span>f</code></pre><h3 id="4-docker-compose配合Dockerfile使用"><a href="#4-docker-compose配合Dockerfile使用" class="headerlink" title="4.docker-compose配合Dockerfile使用"></a>4.docker-compose配合Dockerfile使用</h3><blockquote><p>使用docker-compose.yml文件以及Dockerfile文件在生成自定义镜像的同时启动当前镜像，并且由docker-compose去管理容器</p></blockquote><h4 id="4-1docker-compose文件"><a href="#4-1docker-compose文件" class="headerlink" title="4.1docker-compose文件"></a>4.1docker-compose文件</h4><pre class=" language-powershell"><code class="language-powershell">编写docker<span class="token operator">-</span>compose文件<span class="token comment" spellcheck="true"># yml文件</span>version: <span class="token string">'3.1'</span>services:  ssm:    restart: always    build:            <span class="token comment" spellcheck="true"># 构建自定义镜像</span>      context: <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>      <span class="token comment" spellcheck="true"># 指定dockerfile文件的所在路径</span>      dockerfile: Dockerfile   <span class="token comment" spellcheck="true"># 指定Dockerfile文件名称</span>    image: ssm:1<span class="token punctuation">.</span>0<span class="token punctuation">.</span>1    container_name: ssm    ports:      <span class="token operator">-</span> 8081:8080    environment:      TZ: Asia<span class="token operator">/</span>Shanghai</code></pre><h4 id="4-2-Dockerfile文件"><a href="#4-2-Dockerfile文件" class="headerlink" title="4.2 Dockerfile文件"></a>4.2 Dockerfile文件</h4><pre class=" language-powershell"><code class="language-powershell">编写Dockerfile文件<span class="token keyword">from</span> daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span>library<span class="token operator">/</span>tomcat:8<span class="token punctuation">.</span>5<span class="token punctuation">.</span>15<span class="token operator">-</span>jre8<span class="token function">copy</span> ssm<span class="token punctuation">.</span>war <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>tomcat<span class="token operator">/</span>webapps</code></pre><h4 id="4-3-运行"><a href="#4-3-运行" class="headerlink" title="4.3 运行"></a>4.3 运行</h4><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#可以直接基于docker-compose.yml以及Dockerfile文件构建的自定义镜像</span>docker<span class="token operator">-</span>compose up <span class="token operator">-</span>d<span class="token comment" spellcheck="true"># 如果自定义镜像不存在，会帮助我们构建出自定义镜像，如果自定义镜像已经存在，会直接运行这个自定义镜像</span><span class="token comment" spellcheck="true">#重新构建自定义镜像</span>docker<span class="token operator">-</span>compose build<span class="token comment" spellcheck="true">#运行当前内容，并重新构建</span>docker<span class="token operator">-</span>compose up <span class="token operator">-</span>d <span class="token operator">--</span>build</code></pre><h2 id="九、CI、CD介绍及准备"><a href="#九、CI、CD介绍及准备" class="headerlink" title="九、CI、CD介绍及准备"></a>九、CI、CD介绍及准备</h2><h3 id="1-CI、CD引言"><a href="#1-CI、CD引言" class="headerlink" title="1.CI、CD引言"></a>1.CI、CD引言</h3><blockquote><p>项目部署<br>1.将项目通过maven进行编译打包<br>2.将文件上传到指定的服务器中<br>3.将war包放到tomcat的目录中<br>4.通过Dockerfile将Tomcat和war包转成一个镜像，由DockerCompose去运行容器 项目更新后，需要将上述流程再次的从头到尾的执行一次，如果每次更新一次都执行一次上述操作，很费时，费力。我们就可以通过CI、CD帮助我们实现持续集成，持续交付和部署</p></blockquote><h3 id="2-CI介绍"><a href="#2-CI介绍" class="headerlink" title="2.CI介绍"></a>2.CI介绍</h3><blockquote><p>CI（continuous intergration）持续集成<br>持续集成：编写代码时，完成了一个功能后，立即提交代码到Git仓库中，将项目重新的构建并且测试。<br>1.快速发现错误。<br>2.防止代码偏离主分支。</p></blockquote><h3 id="3-搭建Gitlab服务器"><a href="#3-搭建Gitlab服务器" class="headerlink" title="3.搭建Gitlab服务器"></a>3.搭建Gitlab服务器</h3><h4 id="3-1-准备环境"><a href="#3-1-准备环境" class="headerlink" title="3.1.准备环境"></a>3.1.准备环境</h4><p>实现CI，需要使用到Gitlab远程仓库，先通过Docker搭建Gitlab</p><blockquote><p>创建一个全新的虚拟机，并且至少指定4G的运行内存，4G运行内存是Gitlab推荐的内存大小。<br>并且安装Docker以及Docker-Compose</p></blockquote><h4 id="3-2-修改ssh的22端口"><a href="#3-2-修改ssh的22端口" class="headerlink" title="3.2 修改ssh的22端口"></a>3.2 修改ssh的22端口</h4><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#将ssh的默认22端口，修改为60022端口，因为Gitlab需要占用22端口</span>vi <span class="token operator">/</span>etc<span class="token operator">/</span>ssh<span class="token operator">/</span>sshd_config  PORT 22 <span class="token operator">-</span>> 60022systemctl restart sshd</code></pre><h4 id="3-3-编写docker-compose-yml"><a href="#3-3-编写docker-compose-yml" class="headerlink" title="3.3 编写docker-compose.yml"></a>3.3 编写docker-compose.yml</h4><pre class=" language-powershell"><code class="language-powershell">docker<span class="token operator">-</span>compose<span class="token punctuation">.</span>yml文件去安装gitlab（下载和运行的时间比较长的）version: <span class="token string">'3.1'</span>services: gitlab:  image: <span class="token string">'twang2218/gitlab-ce-zh:11.1.4'</span>  container_name: <span class="token string">"gitlab"</span>  restart: always  privileged: true  hostname: <span class="token string">'gitlab'</span>  environment:   TZ: <span class="token string">'Asia/Shanghai'</span>   GITLAB_OMNIBUS_CONFIG: <span class="token punctuation">|</span>    external_url <span class="token string">'http://192.168.199.110'</span>    gitlab_rails<span class="token punctuation">[</span><span class="token string">'time_zone'</span><span class="token punctuation">]</span> = <span class="token string">'Asia/Shanghai'</span>    gitlab_rails<span class="token punctuation">[</span><span class="token string">'smtp_enable'</span><span class="token punctuation">]</span> = true    gitlab_rails<span class="token punctuation">[</span><span class="token string">'gitlab_shell_ssh_port'</span><span class="token punctuation">]</span> = 22  ports:   <span class="token operator">-</span> <span class="token string">'80:80'</span>   <span class="token operator">-</span> <span class="token string">'443:443'</span>   <span class="token operator">-</span> <span class="token string">'22:22'</span>  volumes:   <span class="token operator">-</span> <span class="token operator">/</span>opt<span class="token operator">/</span>docker_gitlab<span class="token operator">/</span>config:<span class="token operator">/</span>etc<span class="token operator">/</span>gitlab   <span class="token operator">-</span> <span class="token operator">/</span>opt<span class="token operator">/</span>docker_gitlab<span class="token operator">/</span><span class="token keyword">data</span>:<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>opt<span class="token operator">/</span>gitlab   <span class="token operator">-</span> <span class="token operator">/</span>opt<span class="token operator">/</span>docker_gitlab<span class="token operator">/</span>logs:<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>log<span class="token operator">/</span>gitlab</code></pre><h2 id="十、搭建GitlabRunner"><a href="#十、搭建GitlabRunner" class="headerlink" title="十、搭建GitlabRunner"></a>十、搭建GitlabRunner</h2><h3 id="1-准备文件"><a href="#1-准备文件" class="headerlink" title="1.准备文件"></a>1.准备文件</h3><pre class=" language-powershell"><code class="language-powershell">daemon<span class="token punctuation">.</span>json<span class="token punctuation">{</span>“registry<span class="token operator">-</span>mirrors”: <span class="token punctuation">[</span>“https:<span class="token operator">/</span><span class="token operator">/</span>registry<span class="token punctuation">.</span>docker<span class="token operator">-</span>cn<span class="token punctuation">.</span>com”<span class="token punctuation">]</span><span class="token punctuation">,</span>“insecure<span class="token operator">-</span>registries”: <span class="token namespace">[ip:ports]</span><span class="token punctuation">}</span>文件夹 environment里面准备maven安装包，jdk1<span class="token punctuation">.</span>8安装包，Dockerfile，daemon<span class="token punctuation">.</span>json以及docker<span class="token operator">-</span>compose</code></pre><h3 id="2-开始搭建"><a href="#2-开始搭建" class="headerlink" title="2.开始搭建"></a>2.开始搭建</h3><blockquote><p>创建工作目录 /usr/local/docker_gitlab-runner<br>将docker-compose.yml文件以及environment目录全部复制到上述目录中 在宿主机启动docker程序后先执行 sudo<br>chown root:root /var/run/docker.sock (如果重启过 docker,重新执行)<br>在/usr/local/docker_gitlab-runner 目录中执行docker-compose up -d –build 启动容器<br>添加容器权限，保证容器可以使用宿主机的dockerdocker exec -it gitlab-runner usermod -aG<br>root gitlab-runner 注册Runner信息到gitlab</p></blockquote><h3 id="3-进入后续步骤"><a href="#3-进入后续步骤" class="headerlink" title="3.进入后续步骤"></a>3.进入后续步骤</h3><pre class=" language-powershell"><code class="language-powershell">docker exec <span class="token operator">-</span>it gitlab<span class="token operator">-</span>runner gitlab<span class="token operator">-</span>runner register<span class="token comment" spellcheck="true"># 输入 GitLab 地址</span>Please enter the gitlab<span class="token operator">-</span>ci coordinator URL <span class="token punctuation">(</span>e<span class="token punctuation">.</span>g<span class="token punctuation">.</span> https:<span class="token operator">/</span><span class="token operator">/</span>gitlab<span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token punctuation">)</span>:http:<span class="token operator">/</span><span class="token operator">/</span>192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>199<span class="token punctuation">.</span>109<span class="token operator">/</span><span class="token comment" spellcheck="true"># 输入 GitLab Token</span>Please enter the gitlab<span class="token operator">-</span>ci token <span class="token keyword">for</span> this runner:1Lxq_f1NRfCfeNbE5WRh<span class="token comment" spellcheck="true"># 输入 Runner 的说明</span>Please enter the gitlab<span class="token operator">-</span>ci description <span class="token keyword">for</span> this runner:可以为空<span class="token comment" spellcheck="true"># 设置 Tag，可以用于指定在构建规定的 tag 时触发 ci</span>Please enter the gitlab<span class="token operator">-</span>ci tags <span class="token keyword">for</span> this runner <span class="token punctuation">(</span>comma separated<span class="token punctuation">)</span>:deploy<span class="token comment" spellcheck="true"># 这里选择 true ，可以用于代码上传后直接执行（根据版本，也会没有次选项）</span>Whether to run untagged builds <span class="token namespace">[true/false]</span>:true<span class="token comment" spellcheck="true"># 这里选择 false，可以直接回车，默认为 false（根据版本，也会没有次选项）</span>Whether to lock Runner to current project <span class="token namespace">[true/false]</span>:false<span class="token comment" spellcheck="true"># 选择 runner 执行器，这里我们选择的是 shell</span>Please enter the executor: virtualbox<span class="token punctuation">,</span> docker<span class="token operator">+</span>machine<span class="token punctuation">,</span> parallels<span class="token punctuation">,</span> shell<span class="token punctuation">,</span> ssh<span class="token punctuation">,</span> docker<span class="token operator">-</span>ssh<span class="token operator">+</span>machine<span class="token punctuation">,</span> kubernetes<span class="token punctuation">,</span> docker<span class="token punctuation">,</span> docker<span class="token operator">-</span>ssh:shell</code></pre><h2 id="十一、整合项目入门测试"><a href="#十一、整合项目入门测试" class="headerlink" title="十一、整合项目入门测试"></a>十一、整合项目入门测试</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h3><blockquote><p>创建maven工程，添加web.xml文件，编写HTML页面</p></blockquote><h3 id="2-编写-gitlab-ci-yml文件"><a href="#2-编写-gitlab-ci-yml文件" class="headerlink" title="2.编写.gitlab-ci.yml文件"></a>2.编写.gitlab-ci.yml文件</h3><pre class=" language-powershell"><code class="language-powershell">stages:  <span class="token operator">-</span> testtest:  stage: test  script:    <span class="token operator">-</span> <span class="token function">echo</span> first test ci   <span class="token comment" spellcheck="true"># 输入的命令</span></code></pre><h3 id="3-将maven工程推送到gitlab中"><a href="#3-将maven工程推送到gitlab中" class="headerlink" title="3.将maven工程推送到gitlab中"></a>3.将maven工程推送到gitlab中</h3><pre class=" language-powershell"><code class="language-powershell">执行git命令推送到Gitlabgit push origin master</code></pre><h3 id="4-查看效果"><a href="#4-查看效果" class="headerlink" title="4.查看效果"></a>4.查看效果</h3><blockquote><p>可以在gitlab中查看到gitlab-ci.yml编写的内容</p></blockquote><h2 id="十二、完善项目配置"><a href="#十二、完善项目配置" class="headerlink" title="十二、完善项目配置"></a>十二、完善项目配置</h2><blockquote><p>添加Dockerfile以及docker-compose.yml， 并修改.gitlab-ci.yml文件</p></blockquote><h3 id="1-创建Dockerfile"><a href="#1-创建Dockerfile" class="headerlink" title="1.创建Dockerfile"></a>1.创建Dockerfile</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># Dockerfile</span><span class="token keyword">FROM</span> daocloud<span class="token punctuation">.</span>io<span class="token operator">/</span>library<span class="token operator">/</span>tomcat:8<span class="token punctuation">.</span>5<span class="token punctuation">.</span>15<span class="token operator">-</span>jre8<span class="token function">COPY</span> testci<span class="token punctuation">.</span>war <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>tomcat<span class="token operator">/</span>webapps</code></pre><h3 id="2-创建docker-compose-yml"><a href="#2-创建docker-compose-yml" class="headerlink" title="2.创建docker-compose.yml"></a>2.创建docker-compose.yml</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># docker-compose.yml</span>version: <span class="token string">"3.1"</span>services:  testci:    build: docker    restart: always    container_name: testci    ports:      <span class="token operator">-</span> 8080:8080</code></pre><h3 id="3-修改-gitlab-ci-yml"><a href="#3-修改-gitlab-ci-yml" class="headerlink" title="3.修改.gitlab-ci.yml"></a>3.修改.gitlab-ci.yml</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># ci.yml</span>stages:  <span class="token operator">-</span> testtest:  stage: test  script:    <span class="token operator">-</span> <span class="token function">echo</span> first test ci    <span class="token operator">-</span> <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>maven<span class="token operator">/</span>apache<span class="token operator">-</span>maven<span class="token operator">-</span>3<span class="token punctuation">.</span>6<span class="token punctuation">.</span>3<span class="token operator">/</span>bin<span class="token operator">/</span>mvn package    <span class="token operator">-</span> <span class="token function">cp</span> target<span class="token operator">/</span>testci<span class="token operator">-</span>1<span class="token punctuation">.</span>0<span class="token operator">-</span>SNAPSHOT<span class="token punctuation">.</span>war docker<span class="token operator">/</span>testci<span class="token punctuation">.</span>war    <span class="token operator">-</span> docker<span class="token operator">-</span>compose down    <span class="token operator">-</span> docker<span class="token operator">-</span>compose up <span class="token operator">-</span>d <span class="token operator">--</span>build    <span class="token operator">-</span> docker rmi $<span class="token punctuation">(</span>docker images <span class="token operator">-</span>qf dangling=true<span class="token punctuation">)</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux运维教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/3eeb.html"/>
      <url>/post/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>hexo clean</p><p>hexo g</p><p>hexo d</p><p>hexo s</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> INIT </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
